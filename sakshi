BFS operations:

#include <stdio.h>
#include <stdlib.h>

// Define the structure for a node in the BST
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Function to insert a new node into the BST
struct Node* insert(struct Node* root, int data) {
    if (root == NULL) {
        return createNode(data);
    }

    if (data < root->data) {
        root->left = insert(root->left, data);
    } else if (data > root->data) {
        root->right = insert(root->right, data);
    }
    
    return root;
}

// Function to perform inorder traversal (Left, Root, Right)
void inorder(struct Node* root) {
    if (root != NULL) {
        inorder(root->left);
        printf("%d ", root->data);
        inorder(root->right);
    }
}

// Function to perform preorder traversal (Root, Left, Right)
void preorder(struct Node* root) {
    if (root != NULL) {
        printf("%d ", root->data);
        preorder(root->left);
        preorder(root->right);
    }
}

// Function to perform postorder traversal (Left, Right, Root)
void postorder(struct Node* root) {
    if (root != NULL) {
        postorder(root->left);
        postorder(root->right);
        printf("%d ", root->data);
    }
}

// Function to search for a value in the BST
struct Node* search(struct Node* root, int key) {
    if (root == NULL || root->data == key) {
        return root;
    }

    if (key < root->data) {
        return search(root->left, key);
    } else {
        return search(root->right, key);
    }
}

// Function to find the node with the minimum value
struct Node* findMin(struct Node* root) {
    while (root->left != NULL) {
        root = root->left;
    }
    return root;
}

// Function to delete a node from the BST
struct Node* delete(struct Node* root, int key) {
    if (root == NULL) {
        return root;
    }

    // If the key to be deleted is smaller than the root's key, go to the left subtree
    if (key < root->data) {
        root->left = delete(root->left, key);
    }
    // If the key to be deleted is larger than the root's key, go to the right subtree
    else if (key > root->data) {
        root->right = delete(root->right, key);
    }
    // If the key to be deleted is the same as the root's key, then this is the node to be deleted
    else {
        // Node with only one child or no child
        if (root->left == NULL) {
            struct Node* temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            struct Node* temp = root->left;
            free(root);
            return temp;
        }

        // Node with two children: Get the inorder successor (smallest in the right subtree)
        struct Node* temp = findMin(root->right);

        // Copy the inorder successor's content to this node
        root->data = temp->data;

        // Delete the inorder successor
        root->right = delete(root->right, temp->data);
    }
    return root;
}

// Function to display menu options
void displayMenu() {
    printf("\nBST Operations Menu:\n");
    printf("1. Insert Node\n");
    printf("2. Inorder Traversal\n");
    printf("3. Preorder Traversal\n");
    printf("4. Postorder Traversal\n");
    printf("5. Search for a Node\n");
    printf("6. Delete Node\n");
    printf("7. Exit\n");
}

int main() {
    struct Node* root = NULL;
    int choice, value;

    do {
        displayMenu();
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch(choice) {
            case 1:
                printf("Enter the value to insert: ");
                scanf("%d", &value);
                root = insert(root, value);
                break;

            case 2:
                printf("Inorder Traversal: ");
                inorder(root);
                printf("\n");
                break;

            case 3:
                printf("Preorder Traversal: ");
                preorder(root);
                printf("\n");
                break;

            case 4:
                printf("Postorder Traversal: ");
                postorder(root);
                printf("\n");
                break;

            case 5:
                printf("Enter value to search: ");
                scanf("%d", &value);
                if (search(root, value) != NULL) {
                    printf("Node with value %d found in the BST.\n", value);
                } else {
                    printf("Node with value %d not found in the BST.\n", value);
                }
                break;

            case 6:
                printf("Enter value to delete: ");
                scanf("%d", &value);
                root = delete(root, value);
                printf("Node with value %d deleted.\n", value);
                break;

            case 7:
                printf("Exiting program...\n");
                break;

            default:
                printf("Invalid choice, please try again.\n");
        }
    } while(choice != 7);

    return 0;
}



-> implement heap sort
#include <stdio.h>
#include <stdlib.h>

// Function to heapify a subtree rooted at index i
// n is the size of the heap
void heapify(int arr[], int n, int i) {
    int largest = i; // Initialize largest as root
    int left = 2 * i + 1; // Left child
    int right = 2 * i + 2; // Right child

    // If left child is larger than root
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }

    // If right child is larger than largest so far
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }

    // If largest is not root, swap it and continue heapifying
    if (largest != i) {
        // Swap arr[i] and arr[largest]
        int temp = arr[i];
        arr[i] = arr[largest];
        arr[largest] = temp;

        // Recursively heapify the affected subtree
        heapify(arr, n, largest);
    }
}

// Function to perform heap sort
void heapSort(int arr[], int n) {
    // Build a max heap
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }

    // One by one extract elements from the heap
    for (int i = n - 1; i >= 1; i--) {
        // Swap the root (maximum element) with the last element
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;

        // Call heapify on the reduced heap
        heapify(arr, i, 0);
    }
}

// Function to print the array
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int n;

    // Take input from the user
    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements:\n");
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    // Perform heap sort
    heapSort(arr, n);

    // Print the sorted array
    printf("Sorted array: ");
    printArray(arr, n);

    return 0;
}


-> implement priority queue using heap
#include <stdio.h>
#include <stdlib.h>

// Structure for a priority queue
struct PriorityQueue {
    int *arr;
    int size;
    int capacity;
};

// Function to create a priority queue
struct PriorityQueue* createPriorityQueue(int capacity) {
    struct PriorityQueue* pq = (struct PriorityQueue*)malloc(sizeof(struct PriorityQueue));
    pq->capacity = capacity;
    pq->size = 0;
    pq->arr = (int*)malloc(capacity * sizeof(int));
    return pq;
}

// Function to swap two elements
void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// Function to heapify a subtree rooted at index i
void heapify(struct PriorityQueue* pq, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    // If left child is larger than root
    if (left < pq->size && pq->arr[left] > pq->arr[largest]) {
        largest = left;
    }

    // If right child is larger than largest so far
    if (right < pq->size && pq->arr[right] > pq->arr[largest]) {
        largest = right;
    }

    // If largest is not root, swap and continue heapifying
    if (largest != i) {
        swap(&pq->arr[i], &pq->arr[largest]);
        heapify(pq, largest);
    }
}

// Function to insert a new element into the priority queue
void insert(struct PriorityQueue* pq, int value) {
    if (pq->size == pq->capacity) {
        printf("Priority Queue is full\n");
        return;
    }

    // Insert the new element at the end
    pq->arr[pq->size] = value;
    int i = pq->size;
    pq->size++;

    // Fix the max-heap property if it's violated
    while (i > 0 && pq->arr[i] > pq->arr[(i - 1) / 2]) {
        swap(&pq->arr[i], &pq->arr[(i - 1) / 2]);
        i = (i - 1) / 2;
    }
}

// Function to extract (remove) the element with the highest priority (max)
int extractMax(struct PriorityQueue* pq) {
    if (pq->size == 0) {
        printf("Priority Queue is empty\n");
        return -1;  // Return a sentinel value indicating empty queue
    }

    // The root contains the maximum element
    int root = pq->arr[0];

    // Move the last element to the root
    pq->arr[0] = pq->arr[pq->size - 1];
    pq->size--;

    // Call heapify to restore the max-heap property
    heapify(pq, 0);

    return root;
}

// Function to get the maximum element from the priority queue (without removing it)
int peek(struct PriorityQueue* pq) {
    if (pq->size == 0) {
        printf("Priority Queue is empty\n");
        return -1;
    }
    return pq->arr[0];
}

// Function to display the contents of the priority queue
void printQueue(struct PriorityQueue* pq) {
    if (pq->size == 0) {
        printf("Priority Queue is empty\n");
        return;
    }

    for (int i = 0; i < pq->size; i++) {
        printf("%d ", pq->arr[i]);
    }
    printf("\n");
}

int main() {
    int capacity;

    printf("Enter the capacity of the priority queue: ");
    scanf("%d", &capacity);

    struct PriorityQueue* pq = createPriorityQueue(capacity);

    int choice, value;
    do {
        printf("\nPriority Queue Operations:\n");
        printf("1. Insert an element\n");
        printf("2. Extract max (dequeue)\n");
        printf("3. Peek (get max)\n");
        printf("4. Display Queue\n");
        printf("5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter the value to insert: ");
                scanf("%d", &value);
                insert(pq, value);
                break;
            case 2:
                value = extractMax(pq);
                if (value != -1) {
                    printf("Extracted max: %d\n", value);
                }
                break;
            case 3:
                value = peek(pq);
                if (value != -1) {
                    printf("Max element: %d\n", value);
                }
                break;
            case 4:
                printf("Priority Queue: ");
                printQueue(pq);
                break;
            case 5:
                printf("Exiting program...\n");
                break;
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 5);

    // Free memory
    free(pq->arr);
    free(pq);

    return 0;
}


-> implement BFS
#include <stdio.h>
#include <stdlib.h>

// Structure for a queue
struct Queue {
    int *arr;
    int front, rear;
    int capacity;
};

// Function to create a queue
struct Queue* createQueue(int capacity) {
    struct Queue* queue = (struct Queue*)malloc(sizeof(struct Queue));
    queue->capacity = capacity;
    queue->front = queue->rear = -1;
    queue->arr = (int*)malloc(capacity * sizeof(int));
    return queue;
}

// Function to check if the queue is empty
int isEmpty(struct Queue* queue) {
    return queue->front == -1;
}

// Function to enqueue an element into the queue
void enqueue(struct Queue* queue, int value) {
    if (queue->rear == queue->capacity - 1) {
        printf("Queue is full\n");
        return;
    }
    if (queue->front == -1) {
        queue->front = 0;
    }
    queue->arr[++queue->rear] = value;
}

// Function to dequeue an element from the queue
int dequeue(struct Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty\n");
        return -1;
    }
    int item = queue->arr[queue->front];
    if (queue->front == queue->rear) {
        queue->front = queue->rear = -1; // Queue is empty after dequeue
    } else {
        queue->front++;
    }
    return item;
}

// Function to implement BFS on a graph
void BFS(int **graph, int n, int start) {
    int visited[n];  // Array to track visited nodes
    struct Queue* queue = createQueue(n);  // Create a queue for BFS

    // Initialize visited array as false (0)
    for (int i = 0; i < n; i++) {
        visited[i] = 0;
    }

    // Enqueue the starting node and mark it as visited
    enqueue(queue, start);
    visited[start] = 1;

    printf("BFS Traversal starting from node %d: ", start);

    // BFS loop
    while (!isEmpty(queue)) {
        int current = dequeue(queue);  // Dequeue a node
        printf("%d ", current);  // Print the node

        // Explore all unvisited neighbors of the current node
        for (int i = 0; i < n; i++) {
            if (graph[current][i] == 1 && !visited[i]) {  // If there's an edge and the node is unvisited
                enqueue(queue, i);
                visited[i] = 1;  // Mark the neighbor as visited
            }
        }
    }

    printf("\n");
}

int main() {
    int n, m;

    // Take the number of nodes and edges as input
    printf("Enter the number of nodes: ");
    scanf("%d", &n);
    printf("Enter the number of edges: ");
    scanf("%d", &m);

    // Dynamically allocate memory for the adjacency matrix
    int **graph = (int **)malloc(n * sizeof(int *));
    for (int i = 0; i < n; i++) {
        graph[i] = (int *)malloc(n * sizeof(int));
    }

    // Initialize the graph (adjacency matrix) with zeros
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            graph[i][j] = 0;
        }
    }

    // Take the edges as input and update the adjacency matrix
    printf("Enter the edges (u v) where u and v are node indices (0-based):\n");
    for (int i = 0; i < m; i++) {
        int u, v;
        scanf("%d %d", &u, &v);
        graph[u][v] = 1;
        graph[v][u] = 1; // Since it's an undirected graph
    }

    // Take the starting node for BFS
    int start;
    printf("Enter the starting node for BFS: ");
    scanf("%d", &start);

    // Call BFS function
    BFS(graph, n, start);

    // Free dynamically allocated memory
    for (int i = 0; i < n; i++) {
        free(graph[i]);
    }
    free(graph);

    return 0;
}


->  Implement hashing 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TABLE_SIZE 10

// Define a structure for a linked list node to store key-value pairs
struct Node {
    int key;
    int value;
    struct Node* next;
};

// Define a structure for the hash table (array of linked lists)
struct HashTable {
    struct Node* table[TABLE_SIZE];
};

// Function to create a new hash table
struct HashTable* createHashTable() {
    struct HashTable* ht = (struct HashTable*)malloc(sizeof(struct HashTable));
    
    // Initialize all table entries to NULL
    for (int i = 0; i < TABLE_SIZE; i++) {
        ht->table[i] = NULL;
    }
    return ht;
}

// Hash function to map a key to an index
int hash(int key) {
    return key % TABLE_SIZE;
}

// Function to insert a key-value pair into the hash table
void insert(struct HashTable* ht, int key, int value) {
    int index = hash(key);  // Calculate the index using the hash function
    
    // Create a new node for the key-value pair
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->key = key;
    newNode->value = value;
    newNode->next = NULL;
    
    // If there's no collision, insert at the empty index
    if (ht->table[index] == NULL) {
        ht->table[index] = newNode;
    } else {
        // If a collision occurs, add the new node to the linked list at this index
        newNode->next = ht->table[index];
        ht->table[index] = newNode;
    }
    printf("Inserted key %d with value %d\n", key, value);
}

// Function to search for a value by key
int search(struct HashTable* ht, int key) {
    int index = hash(key);  // Calculate the index using the hash function
    
    struct Node* temp = ht->table[index];
    while (temp != NULL) {
        if (temp->key == key) {
            return temp->value;  // Return the value if the key is found
        }
        temp = temp->next;
    }
    return -1;  // Return -1 if the key is not found
}

// Function to delete a key-value pair from the hash table
void delete(struct HashTable* ht, int key) {
    int index = hash(key);  // Calculate the index using the hash function
    
    struct Node* temp = ht->table[index];
    struct Node* prev = NULL;
    
    // Traverse the linked list to find the node with the given key
    while (temp != NULL) {
        if (temp->key == key) {
            if (prev == NULL) {
                // The node to be deleted is the first node in the list
                ht->table[index] = temp->next;
            } else {
                // Skip the node to be deleted
                prev->next = temp->next;
            }
            free(temp);  // Free the memory of the deleted node
            printf("Deleted key %d\n", key);
            return;
        }
        prev = temp;
        temp = temp->next;
    }
    
    printf("Key %d not found\n", key);
}

// Function to display the contents of the hash table
void display(struct HashTable* ht) {
    for (int i = 0; i < TABLE_SIZE; i++) {
        struct Node* temp = ht->table[i];
        if (temp != NULL) {
            printf("Index %d: ", i);
            while (temp != NULL) {
                printf("-> (Key: %d, Value: %d) ", temp->key, temp->value);
                temp = temp->next;
            }
            printf("\n");
        }
    }
}

int main() {
    struct HashTable* ht = createHashTable();
    
    int choice, key, value;
    
    do {
        printf("\nMenu:\n");
        printf("1. Insert\n");
        printf("2. Search\n");
        printf("3. Delete\n");
        printf("4. Display Hash Table\n");
        printf("5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        
        switch (choice) {
            case 1:
                printf("Enter key to insert: ");
                scanf("%d", &key);
                printf("Enter value: ");
                scanf("%d", &value);
                insert(ht, key, value);
                break;
                
            case 2:
                printf("Enter key to search: ");
                scanf("%d", &key);
                value = search(ht, key);
                if (value != -1) {
                    printf("Found key %d with value %d\n", key, value);
                } else {
                    printf("Key %d not found\n", key);
                }
                break;
                
            case 3:
                printf("Enter key to delete: ");
                scanf("%d", &key);
                delete(ht, key);
                break;
                
            case 4:
                display(ht);
                break;
                
            case 5:
                printf("Exiting program...\n");
                break;
                
            default:
                printf("Invalid choice!\n");
        }
    } while (choice != 5);
    
    return 0;
}


-> implement DFS
#include <stdio.h>
#include <stdlib.h>

#define MAX_NODES 10

// Function to perform DFS traversal on the graph
void DFS(int graph[MAX_NODES][MAX_NODES], int visited[MAX_NODES], int node, int n) {
    // Mark the current node as visited
    visited[node] = 1;
    printf("%d ", node);

    // Visit all the neighbors of the current node
    for (int i = 0; i < n; i++) {
        if (graph[node][i] == 1 && !visited[i]) {
            DFS(graph, visited, i, n);
        }
    }
}

// Main function
int main() {
    int graph[MAX_NODES][MAX_NODES];
    int visited[MAX_NODES] = {0};  // Initialize visited array to 0
    int n, m, u, v, start;

    // Take the number of nodes and edges as input
    printf("Enter the number of nodes: ");
    scanf("%d", &n);
    printf("Enter the number of edges: ");
    scanf("%d", &m);

    // Initialize the graph with 0 (no edges)
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            graph[i][j] = 0;
        }
    }

    // Take the edges as input and update the graph
    printf("Enter the edges (u v) where u and v are node indices (0-based):\n");
    for (int i = 0; i < m; i++) {
        scanf("%d %d", &u, &v);
        graph[u][v] = 1;
        graph[v][u] = 1;  // For undirected graph
    }

    // Take the starting node for DFS
    printf("Enter the starting node for DFS: ");
    scanf("%d", &start);

    // Perform DFS starting from the given node
    printf("DFS Traversal starting from node %d: ", start);
    DFS(graph, visited, start, n);

    printf("\n");

    return 0;
}

->Binary Search
#include <stdio.h>

// Function for Binary Search
int binarySearch(int arr[], int n, int key) {
    int low = 0, high = n - 1;

    while (low <= high) {
        // Find the middle element
        int mid = low + (high - low) / 2;

        // Check if the key is present at mid
        if (arr[mid] == key) {
            return mid;  // Key found, return index
        }

        // If the key is smaller than mid, search the left half
        if (arr[mid] > key) {
            high = mid - 1;
        }
        // If the key is larger than mid, search the right half
        else {
            low = mid + 1;
        }
    }

    return -1;  // Key not found
}

int main() {
    int n, key;

    // Input number of elements in the array
    printf("Enter number of elements: ");
    scanf("%d", &n);

    int arr[n];

    // Input the sorted array elements
    printf("Enter the sorted array elements:\n");
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    // Input the key to be searched
    printf("Enter the key to search: ");
    scanf("%d", &key);

    // Call binarySearch function
    int result = binarySearch(arr, n, key);

    // Output the result
    if (result == -1) {
        printf("Element not found in the array\n");
    } else {
        printf("Element found at index %d\n", result);
    }

    return 0;
}


->bubble sort
#include <stdio.h>

// Function to perform Bubble Sort
void bubbleSort(int arr[], int n) {
    int temp;
    // Traverse through all array elements
    for (int i = 0; i < n-1; i++) {
        // Last i elements are already in place
        for (int j = 0; j < n-i-1; j++) {
            // Swap if the element found is greater than the next element
            if (arr[j] > arr[j+1]) {
                temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}

// Function to print the array
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr)/sizeof(arr[0]);

    printf("Original array: \n");
    printArray(arr, n);

    bubbleSort(arr, n);

    printf("Sorted array: \n");
    printArray(arr, n);

    return 0;
}

-> insertion sort
#include <stdio.h>

// Function to perform Insertion Sort
void insertionSort(int arr[], int n) {
    int key, j;
    // Traverse through 1 to n-1
    for (int i = 1; i < n; i++) {
        key = arr[i];
        j = i - 1;

        // Move elements of arr[0..i-1], that are greater than key,
        // to one position ahead of their current position
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}

// Function to print the array
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int arr[] = {12, 11, 13, 5, 6};
    int n = sizeof(arr)/sizeof(arr[0]);

    printf("Original array: \n");
    printArray(arr, n);

    insertionSort(arr, n);

    printf("Sorted array: \n");
    printArray(arr, n);

    return 0;
}

->selection sort
#include <stdio.h>

// Function to perform Selection Sort
void selectionSort(int arr[], int n) {
    int minIndex, temp;
    // One by one move the boundary of unsorted subarray
    for (int i = 0; i < n-1; i++) {
        minIndex = i;
        
        // Find the minimum element in the unsorted array
        for (int j = i+1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        
        // Swap the found minimum element with the first element
        temp = arr[minIndex];
        arr[minIndex] = arr[i];
        arr[i] = temp;
    }
}

// Function to print the array
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int arr[] = {64, 25, 12, 22, 11};
    int n = sizeof(arr)/sizeof(arr[0]);

    printf("Original array: \n");
    printArray(arr, n);

    selectionSort(arr, n);

    printf("Sorted array: \n");
    printArray(arr, n);

    return 0;
}


-> linear search
#include <stdio.h>

// Function for Linear Search
int linearSearch(int arr[], int n, int key) {
    for (int i = 0; i < n; i++) {
        // If the key is found, return the index
        if (arr[i] == key) {
            return i;
        }
    }
    // If the key is not found, return -1
    return -1;
}

int main() {
    int n, key;

    // Input the number of elements
    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    // Input the array elements
    printf("Enter the elements of the array:\n");
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    // Input the key to search for
    printf("Enter the key to search: ");
    scanf("%d", &key);

    // Call linearSearch function
    int result = linearSearch(arr, n, key);

    // Output the result
    if (result == -1) {
        printf("Element not found in the array\n");
    } else {
        printf("Element found at index %d\n", result);
    }

    return 0;
}


-> interpolation search
#include <stdio.h>

// Function for Interpolation Search
int interpolationSearch(int arr[], int n, int key) {
    int low = 0, high = n - 1;

    // Loop to perform search
    while (low <= high && key >= arr[low] && key <= arr[high]) {
        // Calculate the probe position using the interpolation formula
        int pos = low + ((key - arr[low]) * (high - low)) / (arr[high] - arr[low]);

        // Check if the key is present at the probe position
        if (arr[pos] == key) {
            return pos;
        }

        // If key is larger, search the right half
        if (arr[pos] < key) {
            low = pos + 1;
        }
        // If key is smaller, search the left half
        else {
            high = pos - 1;
        }
    }

    // If the key is not found, return -1
    return -1;
}

int main() {
    int n, key;

    // Input the number of elements
    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    // Input the array elements
    printf("Enter the sorted elements of the array:\n");
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    // Input the key to search for
    printf("Enter the key to search: ");
    scanf("%d", &key);

    // Call interpolationSearch function
    int result = interpolationSearch(arr, n, key);

    // Output the result
    if (result == -1) {
        printf("Element not found in the array\n");
    } else {
        printf("Element found at index %d\n", result);
    }

    return 0;
}


->Implement the quick Sort
#include <stdio.h>

// Function to swap two elements
void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// Partition function to rearrange elements based on pivot
int partition(int arr[], int low, int high) {
    int pivot = arr[high];  // pivot element
    int i = (low - 1);  // Index of smaller element

    for (int j = low; j < high; j++) {
        // If current element is smaller than the pivot, swap it to the left of the pivot
        if (arr[j] < pivot) {
            i++;
            swap(&arr[i], &arr[j]);
        }
    }
    // Place the pivot element in its correct position
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);  // Return the partition index
}

// Quick Sort function
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        // Partitioning index
        int pi = partition(arr, low, high);

        // Recursively sort the left and right sub-arrays
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

// Function to print the array
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int n;

    // Input number of elements
    printf("Enter number of elements: ");
    scanf("%d", &n);

    int arr[n];

    // Input array elements
    printf("Enter the elements of the array:\n");
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    // Call quickSort function
    quickSort(arr, 0, n - 1);

    // Print sorted array
    printf("Sorted array: \n");
    printArray(arr, n);

    return 0;
}

-> Implement radix sort
#include <stdio.h>

// Function to perform Counting Sort based on the digit represented by exp (1s, 10s, 100s, etc.)
void countingSort(int arr[], int n, int exp) {
    int output[n];  // Output array
    int count[10] = {0};  // Count array for digits (0-9)

    // Store count of occurrences of (arr[i] / exp) % 10
    for (int i = 0; i < n; i++) {
        count[(arr[i] / exp) % 10]++;
    }

    // Update count[i] so that it contains the actual position of this digit in output[]
    for (int i = 1; i < 10; i++) {
        count[i] += count[i - 1];
    }

    // Build the output array
    for (int i = n - 1; i >= 0; i--) {
        output[count[(arr[i] / exp) % 10] - 1] = arr[i];
        count[(arr[i] / exp) % 10]--;
    }

    // Copy the output array to arr[], so that arr[] now contains sorted numbers based on the current digit
    for (int i = 0; i < n; i++) {
        arr[i] = output[i];
    }
}

// Function to implement Radix Sort
void radixSort(int arr[], int n) {
    // Find the maximum number to know the number of digits
    int max = arr[0];
    for (int i = 1; i < n; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }

    // Perform counting sort for every digit. The exp is 10^i where i is the current digit number.
    for (int exp = 1; max / exp > 0; exp *= 10) {
        countingSort(arr, n, exp);
    }
}

// Function to print the array
void printArray(int arr[], int n) {
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int n;

    // Input the number of elements
    printf("Enter number of elements: ");
    scanf("%d", &n);

    int arr[n];

    // Input the elements of the array
    printf("Enter the elements of the array:\n");
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    // Perform Radix Sort
    radixSort(arr, n);

    // Print the sorted array
    printf("Sorted array: \n");
    printArray(arr, n);

    return 0;
}


->Implement Merge Sort
#include <stdio.h>

// Function to merge two halves of the array into a sorted array
void merge(int arr[], int left, int mid, int right) {
    // Calculate the size of the two sub-arrays
    int n1 = mid - left + 1;
    int n2 = right - mid;

    // Temporary arrays for the left and right sub-arrays
    int L[n1], R[n2];

    // Copy data to temporary arrays L[] and R[]
    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];

    // Merge the temporary arrays back into the original array
    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // Copy the remaining elements of L[], if any
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    // Copy the remaining elements of R[], if any
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

// Function to implement Merge Sort
void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        // Find the middle point
        int mid = left + (right - left) / 2;

        // Recursively sort the first and second halves
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);

        // Merge the two sorted halves
        merge(arr, left, mid, right);
    }
}

// Function to print the array
void printArray(int arr[], int n) {
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int n;

    // Input the number of elements
    printf("Enter number of elements: ");
    scanf("%d", &n);

    int arr[n];

    // Input the elements of the array
    printf("Enter the elements of the array:\n");
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    // Perform Merge Sort
    mergeSort(arr, 0, n - 1);

    // Print the sorted array
    printf("Sorted array: \n");
    printArray(arr, n);

    return 0;
}


->Implement Shell Sort
#include <stdio.h>

// Function to perform Shell Sort
void shellSort(int arr[], int n) {
    // Start with a large gap, then reduce it
    for (int gap = n / 2; gap > 0; gap /= 2) {
        // Perform a gapped Insertion Sort for this gap size
        for (int i = gap; i < n; i++) {
            int temp = arr[i];
            int j = i;

            // Shift elements of arr[0..i-gap], that are greater than temp, to one position ahead
            while (j >= gap && arr[j - gap] > temp) {
                arr[j] = arr[j - gap];
                j -= gap;
            }
            arr[j] = temp;
        }
    }
}

// Function to print the array
void printArray(int arr[], int n) {
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int n;

    // Input the number of elements
    printf("Enter number of elements: ");
    scanf("%d", &n);

    int arr[n];

    // Input the elements of the array
    printf("Enter the elements of the array:\n");
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    // Perform Shell Sort
    shellSort(arr, n);

    // Print the sorted array
    printf("Sorted array: \n");
    printArray(arr, n);

    return 0;
}


-> Implementation of Linear Queue using array
#include <stdio.h>
#include <stdlib.h>

#define MAX 5  // Define maximum size of the queue

// Structure to represent a queue
struct Queue {
    int arr[MAX];  // Array to store the elements of the queue
    int front;     // Front of the queue
    int rear;      // Rear of the queue
};

// Function to initialize the queue
void initQueue(struct Queue* q) {
    q->front = -1;
    q->rear = -1;
}

// Function to check if the queue is full
int isFull(struct Queue* q) {
    if (q->rear == MAX - 1) {
        return 1;  // Queue is full
    }
    return 0;
}

// Function to check if the queue is empty
int isEmpty(struct Queue* q) {
    if (q->front == -1 || q->front > q->rear) {
        return 1;  // Queue is empty
    }
    return 0;
}

// Function to add an element to the queue (Enqueue)
void enqueue(struct Queue* q, int value) {
    if (isFull(q)) {
        printf("Queue is full. Cannot enqueue %d\n", value);
    } else {
        if (q->front == -1) {
            q->front = 0;  // Set front to 0 when the first element is added
        }
        q->rear++;
        q->arr[q->rear] = value;  // Insert the element at the rear
        printf("Enqueued %d\n", value);
    }
}

// Function to remove an element from the queue (Dequeue)
void dequeue(struct Queue* q) {
    if (isEmpty(q)) {
        printf("Queue is empty. Cannot dequeue.\n");
    } else {
        printf("Dequeued %d\n", q->arr[q->front]);
        q->front++;  // Move the front pointer to the next element
    }
}

// Function to get the front element of the queue
int front(struct Queue* q) {
    if (isEmpty(q)) {
        printf("Queue is empty.\n");
        return -1;
    } else {
        return q->arr[q->front];
    }
}

// Function to get the rear element of the queue
int rear(struct Queue* q) {
    if (isEmpty(q)) {
        printf("Queue is empty.\n");
        return -1;
    } else {
        return q->arr[q->rear];
    }
}

// Function to display the elements of the queue
void displayQueue(struct Queue* q) {
    if (isEmpty(q)) {
        printf("Queue is empty.\n");
    } else {
        printf("Queue elements: ");
        for (int i = q->front; i <= q->rear; i++) {
            printf("%d ", q->arr[i]);
        }
        printf("\n");
    }
}

int main() {
    struct Queue q;
    initQueue(&q);  // Initialize the queue

    int choice, value;

    // Menu-driven interface
    do {
        printf("\nQueue Operations Menu:\n");
        printf("1. Enqueue\n");
        printf("2. Dequeue\n");
        printf("3. Front\n");
        printf("4. Rear\n");
        printf("5. Display Queue\n");
        printf("6. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:  // Enqueue
                printf("Enter value to enqueue: ");
                scanf("%d", &value);
                enqueue(&q, value);
                break;
            case 2:  // Dequeue
                dequeue(&q);
                break;
            case 3:  // Front
                value = front(&q);
                if (value != -1) {
                    printf("Front element: %d\n", value);
                }
                break;
            case 4:  // Rear
                value = rear(&q);
                if (value != -1) {
                    printf("Rear element: %d\n", value);
                }
                break;
            case 5:  // Display
                displayQueue(&q);
                break;
            case 6:  // Exit
                printf("Exiting program.\n");
                break;
            default:
                printf("Invalid choice, please try again.\n");
        }
    } while (choice != 6);

    return 0;
}


->Implementation of Circular Queue using array
#include <stdio.h>
#include <stdlib.h>

#define MAX 5  // Define maximum size of the queue

// Structure to represent a queue
struct Queue {
    int arr[MAX];  // Array to store queue elements
    int front;     // Front of the queue
    int rear;      // Rear of the queue
};

// Function to initialize the queue
void initQueue(struct Queue* q) {
    q->front = -1;
    q->rear = -1;
}

// Function to check if the queue is full
int isFull(struct Queue* q) {
    if ((q->rear + 1) % MAX == q->front) {
        return 1;  // Queue is full
    }
    return 0;
}

// Function to check if the queue is empty
int isEmpty(struct Queue* q) {
    if (q->front == -1) {
        return 1;  // Queue is empty
    }
    return 0;
}

// Function to add an element to the queue (Enqueue)
void enqueue(struct Queue* q, int value) {
    if (isFull(q)) {
        printf("Queue is full. Cannot enqueue %d\n", value);
    } else {
        if (q->front == -1) {
            q->front = 0;  // Set front to 0 when the first element is added
        }
        q->rear = (q->rear + 1) % MAX;  // Move rear to the next position, wrapping around if needed
        q->arr[q->rear] = value;  // Insert the element at the rear
        printf("Enqueued %d\n", value);
    }
}

// Function to remove an element from the queue (Dequeue)
void dequeue(struct Queue* q) {
    if (isEmpty(q)) {
        printf("Queue is empty. Cannot dequeue.\n");
    } else {
        printf("Dequeued %d\n", q->arr[q->front]);
        if (q->front == q->rear) {
            // If the queue has only one element, reset the queue after dequeue
            q->front = -1;
            q->rear = -1;
        } else {
            q->front = (q->front + 1) % MAX;  // Move front to the next position, wrapping around if needed
        }
    }
}

// Function to get the front element of the queue
int front(struct Queue* q) {
    if (isEmpty(q)) {
        printf("Queue is empty.\n");
        return -1;
    } else {
        return q->arr[q->front];
    }
}

// Function to get the rear element of the queue
int rear(struct Queue* q) {
    if (isEmpty(q)) {
        printf("Queue is empty.\n");
        return -1;
    } else {
        return q->arr[q->rear];
    }
}

// Function to display the elements of the queue
void displayQueue(struct Queue* q) {
    if (isEmpty(q)) {
        printf("Queue is empty.\n");
    } else {
        printf("Queue elements: ");
        int i = q->front;
        while (i != q->rear) {
            printf("%d ", q->arr[i]);
            i = (i + 1) % MAX;  // Wrap around if needed
        }
        printf("%d\n", q->arr[q->rear]);  // Print the last element (rear)
    }
}

int main() {
    struct Queue q;
    initQueue(&q);  // Initialize the queue

    int choice, value;

    // Menu-driven interface
    do {
        printf("\nCircular Queue Operations Menu:\n");
        printf("1. Enqueue\n");
        printf("2. Dequeue\n");
        printf("3. Front\n");
        printf("4. Rear\n");
        printf("5. Display Queue\n");
        printf("6. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:  // Enqueue
                printf("Enter value to enqueue: ");
                scanf("%d", &value);
                enqueue(&q, value);
                break;
            case 2:  // Dequeue
                dequeue(&q);
                break;
            case 3:  // Front
                value = front(&q);
                if (value != -1) {
                    printf("Front element: %d\n", value);
                }
                break;
            case 4:  // Rear
                value = rear(&q);
                if (value != -1) {
                    printf("Rear element: %d\n", value);
                }
                break;
            case 5:  // Display
                displayQueue(&q);
                break;
            case 6:  // Exit
                printf("Exiting program.\n");
                break;
            default:
                printf("Invalid choice, please try again.\n");
        }
    } while (choice != 6);

    return 0;
}


->Implementation of Circular DE Queue using array
#include <stdio.h>
#include <stdlib.h>

#define MAX 5  // Define maximum size of the deque

// Structure to represent a circular deque
struct Deque {
    int arr[MAX];  // Array to store deque elements
    int front;     // Front index of the deque
    int rear;      // Rear index of the deque
};

// Function to initialize the deque
void initDeque(struct Deque* dq) {
    dq->front = -1;
    dq->rear = -1;
}

// Function to check if the deque is full
int isFull(struct Deque* dq) {
    if ((dq->front == 0 && dq->rear == MAX - 1) || (dq->rear == (dq->front - 1) % (MAX - 1))) {
        return 1;  // Deque is full
    }
    return 0;
}

// Function to check if the deque is empty
int isEmpty(struct Deque* dq) {
    if (dq->front == -1) {
        return 1;  // Deque is empty
    }
    return 0;
}

// Function to insert an element at the front of the deque
void insertFront(struct Deque* dq, int value) {
    if (isFull(dq)) {
        printf("Deque is full. Cannot insert %d at front.\n", value);
    } else {
        if (dq->front == -1) {
            dq->front = dq->rear = 0;  // If deque is empty, set both front and rear to 0
        } else if (dq->front == 0) {
            dq->front = MAX - 1;  // Wrap around the front index to the last element
        } else {
            dq->front--;  // Decrease front index
        }
        dq->arr[dq->front] = value;  // Insert the element at the front
        printf("Inserted %d at front.\n", value);
    }
}

// Function to insert an element at the rear of the deque
void insertRear(struct Deque* dq, int value) {
    if (isFull(dq)) {
        printf("Deque is full. Cannot insert %d at rear.\n", value);
    } else {
        if (dq->front == -1) {
            dq->front = dq->rear = 0;  // If deque is empty, set both front and rear to 0
        } else if (dq->rear == MAX - 1) {
            dq->rear = 0;  // Wrap around the rear index to the first element
        } else {
            dq->rear++;  // Increase the rear index
        }
        dq->arr[dq->rear] = value;  // Insert the element at the rear
        printf("Inserted %d at rear.\n", value);
    }
}

// Function to delete an element from the front of the deque
void deleteFront(struct Deque* dq) {
    if (isEmpty(dq)) {
        printf("Deque is empty. Cannot delete from front.\n");
    } else {
        printf("Deleted %d from front.\n", dq->arr[dq->front]);
        if (dq->front == dq->rear) {
            dq->front = dq->rear = -1;  // If there's only one element, reset both pointers
        } else if (dq->front == MAX - 1) {
            dq->front = 0;  // Wrap around the front index to the beginning
        } else {
            dq->front++;  // Move the front pointer
        }
    }
}

// Function to delete an element from the rear of the deque
void deleteRear(struct Deque* dq) {
    if (isEmpty(dq)) {
        printf("Deque is empty. Cannot delete from rear.\n");
    } else {
        printf("Deleted %d from rear.\n", dq->arr[dq->rear]);
        if (dq->front == dq->rear) {
            dq->front = dq->rear = -1;  // If there's only one element, reset both pointers
        } else if (dq->rear == 0) {
            dq->rear = MAX - 1;  // Wrap around the rear index to the last element
        } else {
            dq->rear--;  // Move the rear pointer
        }
    }
}

// Function to get the front element of the deque
int getFront(struct Deque* dq) {
    if (isEmpty(dq)) {
        printf("Deque is empty.\n");
        return -1;
    }
    return dq->arr[dq->front];
}

// Function to get the rear element of the deque
int getRear(struct Deque* dq) {
    if (isEmpty(dq)) {
        printf("Deque is empty.\n");
        return -1;
    }
    return dq->arr[dq->rear];
}

// Function to display the elements of the deque
void displayDeque(struct Deque* dq) {
    if (isEmpty(dq)) {
        printf("Deque is empty.\n");
    } else {
        printf("Deque elements: ");
        int i = dq->front;
        while (i != dq->rear) {
            printf("%d ", dq->arr[i]);
            i = (i + 1) % MAX;  // Wrap around if needed
        }
        printf("%d\n", dq->arr[dq->rear]);  // Print the last element
    }
}

int main() {
    struct Deque dq;
    initDeque(&dq);  // Initialize the deque

    int choice, value;

    // Menu-driven interface
    do {
        printf("\nCircular Deque Operations Menu:\n");
        printf("1. Insert Front\n");
        printf("2. Insert Rear\n");
        printf("3. Delete Front\n");
        printf("4. Delete Rear\n");
        printf("5. Get Front\n");
        printf("6. Get Rear\n");
        printf("7. Display Deque\n");
        printf("8. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:  // Insert Front
                printf("Enter value to insert at front: ");
                scanf("%d", &value);
                insertFront(&dq, value);
                break;
            case 2:  // Insert Rear
                printf("Enter value to insert at rear: ");
                scanf("%d", &value);
                insertRear(&dq, value);
                break;
            case 3:  // Delete Front
                deleteFront(&dq);
                break;
            case 4:  // Delete Rear
                deleteRear(&dq);
                break;
            case 5:  // Get Front
                value = getFront(&dq);
                if (value != -1) {
                    printf("Front element: %d\n", value);
                }
                break;
            case 6:  // Get Rear
                value = getRear(&dq);
                if (value != -1) {
                    printf("Rear element: %d\n", value);
                }
                break;
            case 7:  // Display Deque
                displayDeque(&dq);
                break;
            case 8:  // Exit
                printf("Exiting program.\n");
                break;
            default:
                printf("Invalid choice, please try again.\n");
        }
    } while (choice != 8);

    return 0;
}


->Implementation of Stack using array
#include <stdio.h>
#include <stdlib.h>

#define MAX 5  // Define maximum size of the stack

// Structure to represent a stack
struct Stack {
    int arr[MAX];  // Array to store stack elements
    int top;       // Index of the top element in the stack
};

// Function to initialize the stack
void initStack(struct Stack* s) {
    s->top = -1;  // Stack is empty initially
}

// Function to check if the stack is full
int isFull(struct Stack* s) {
    if (s->top == MAX - 1) {
        return 1;  // Stack is full
    }
    return 0;
}

// Function to check if the stack is empty
int isEmpty(struct Stack* s) {
    if (s->top == -1) {
        return 1;  // Stack is empty
    }
    return 0;
}

// Function to push an element onto the stack
void push(struct Stack* s, int value) {
    if (isFull(s)) {
        printf("Stack is full. Cannot push %d\n", value);
    } else {
        s->arr[++(s->top)] = value;  // Increment top and insert the element
        printf("Pushed %d onto stack\n", value);
    }
}

// Function to pop an element from the stack
void pop(struct Stack* s) {
    if (isEmpty(s)) {
        printf("Stack is empty. Cannot pop.\n");
    } else {
        printf("Popped %d from stack\n", s->arr[s->top]);
        s->top--;  // Decrease top to remove the element
    }
}

// Function to return the top element of the stack without removing it
int peek(struct Stack* s) {
    if (isEmpty(s)) {
        printf("Stack is empty.\n");
        return -1;  // Return a sentinel value for empty stack
    }
    return s->arr[s->top];
}

// Function to display the elements of the stack
void display(struct Stack* s) {
    if (isEmpty(s)) {
        printf("Stack is empty.\n");
    } else {
        printf("Stack elements: ");
        for (int i = s->top; i >= 0; i--) {
            printf("%d ", s->arr[i]);
        }
        printf("\n");
    }
}

int main() {
    struct Stack s;
    initStack(&s);  // Initialize the stack

    int choice, value;

    // Menu-driven interface for stack operations
    do {
        printf("\nStack Operations Menu:\n");
        printf("1. Push\n");
        printf("2. Pop\n");
        printf("3. Peek/Top\n");
        printf("4. Display Stack\n");
        printf("5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:  // Push
                printf("Enter value to push: ");
                scanf("%d", &value);
                push(&s, value);
                break;
            case 2:  // Pop
                pop(&s);
                break;
            case 3:  // Peek/Top
                value = peek(&s);
                if (value != -1) {
                    printf("Top element: %d\n", value);
                }
                break;
            case 4:  // Display
                display(&s);
                break;
            case 5:  // Exit
                printf("Exiting program.\n");
                break;
            default:
                printf("Invalid choice, please try again.\n");
        }
    } while (choice != 5);

    return 0;
}


->Parenthesis check using stack
#include <stdio.h>
#include <stdlib.h>

#define MAX 100  // Define maximum size of the stack

// Stack structure
struct Stack {
    char arr[MAX];  // Array to store stack elements
    int top;        // Index of the top element in the stack
};

// Function to initialize the stack
void initStack(struct Stack* s) {
    s->top = -1;  // Set top to -1 to indicate an empty stack
}

// Function to check if the stack is empty
int isEmpty(struct Stack* s) {
    return s->top == -1;
}

// Function to check if the stack is full
int isFull(struct Stack* s) {
    return s->top == MAX - 1;
}

// Function to push an element onto the stack
void push(struct Stack* s, char value) {
    if (isFull(s)) {
        printf("Stack is full\n");
        return;
    }
    s->arr[++(s->top)] = value;  // Increment top and push value
}

// Function to pop an element from the stack
char pop(struct Stack* s) {
    if (isEmpty(s)) {
        printf("Stack is empty\n");
        return -1;  // Return -1 if stack is empty
    }
    return s->arr[s->top--];  // Pop the top element and decrease top
}

// Function to check if two characters are matching parentheses
int isMatchingPair(char opening, char closing) {
    if (opening == '(' && closing == ')') {
        return 1;
    } else if (opening == '[' && closing == ']') {
        return 1;
    } else if (opening == '{' && closing == '}') {
        return 1;
    }
    return 0;
}

// Function to check if the parentheses in the expression are balanced
int checkParenthesesBalance(char* expr) {
    struct Stack s;
    initStack(&s);  // Initialize the stack

    // Traverse the expression character by character
    for (int i = 0; expr[i] != '\0'; i++) {
        char currentChar = expr[i];

        // If the current character is an opening parenthesis, push it onto the stack
        if (currentChar == '(' || currentChar == '[' || currentChar == '{') {
            push(&s, currentChar);
        }
        // If the current character is a closing parenthesis
        else if (currentChar == ')' || currentChar == ']' || currentChar == '}') {
            // If the stack is empty or the top of the stack does not match
            if (isEmpty(&s) || !isMatchingPair(pop(&s), currentChar)) {
                return 0;  // Unbalanced parentheses
            }
        }
    }

    // If the stack is empty, the parentheses are balanced, else unbalanced
    return isEmpty(&s);
}

int main() {
    char expr[MAX];

    // Input the expression from the user
    printf("Enter an expression: ");
    scanf("%s", expr);

    // Check if the expression has balanced parentheses
    if (checkParenthesesBalance(expr)) {
        printf("The parentheses are balanced.\n");
    } else {
        printf("The parentheses are unbalanced.\n");
    }

    return 0;
}


->Solving the following problems using recursion:
a) Tower of Hanoii
#include <stdio.h>

// Function to solve the Tower of Hanoi problem
// n: number of disks
// source: source rod
// destination: destination rod
// auxiliary: auxiliary rod
void towerOfHanoi(int n, char source, char destination, char auxiliary) {
    // Base case: If there's only one disk to move
    if (n == 1) {
        printf("Move disk 1 from rod %c to rod %c\n", source, destination);
        return;
    }

    // Move top n-1 disks from source to auxiliary
    towerOfHanoi(n - 1, source, auxiliary, destination);

    // Move nth disk from source to destination
    printf("Move disk %d from rod %c to rod %c\n", n, source, destination);

    // Move n-1 disks from auxiliary to destination
    towerOfHanoi(n - 1, auxiliary, destination, source);
}

int main() {
    int n;

    // Input the number of disks
    printf("Enter the number of disks: ");
    scanf("%d", &n);

    // Call the Tower of Hanoi function
    // The rods are labeled 'A', 'B', and 'C'
    towerOfHanoi(n, 'A', 'C', 'B');

    return 0;
}


->Solving the following problems using recursion:
b) Fibonacii series printing 
#include <stdio.h>

// Recursive function to calculate the nth Fibonacci number
int fibonacci(int n) {
    // Base case: Fibonacci(0) = 0 and Fibonacci(1) = 1
    if (n == 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    } else {
        // Recursive case: Fibonacci(n) = Fibonacci(n-1) + Fibonacci(n-2)
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

// Function to print the Fibonacci series up to n
void printFibonacciSeries(int n) {
    for (int i = 0; i < n; i++) {
        printf("%d ", fibonacci(i));
    }
    printf("\n");
}

int main() {
    int n;

    // Input the number of terms to print in the Fibonacci series
    printf("Enter the number of terms in the Fibonacci series: ");
    scanf("%d", &n);

    // Print the Fibonacci series up to n terms
    printFibonacciSeries(n);

    return 0;
}


->Solving the following problems using recursion:
(c) finding gcd of two numbers
#include <stdio.h>

// Recursive function to find GCD of two numbers
int gcd(int a, int b) {
    // Base case: if b is 0, return a
    if (b == 0) {
        return a;
    }
    // Recursive case: GCD(a, b) = GCD(b, a % b)
    return gcd(b, a % b);
}

int main() {
    int a, b;

    // Input two numbers
    printf("Enter two numbers: ");
    scanf("%d %d", &a, &b);

    // Find and display the GCD
    printf("The GCD of %d and %d is: %d\n", a, b, gcd(a, b));

    return 0;
}


->Infix Expression to Postfix Expression Conversion
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

#define MAX 100

// Stack structure
struct Stack {
    char arr[MAX];
    int top;
};

// Function to initialize the stack
void initStack(struct Stack* s) {
    s->top = -1;
}

// Function to check if the stack is empty
int isEmpty(struct Stack* s) {
    return s->top == -1;
}

// Function to check if the stack is full
int isFull(struct Stack* s) {
    return s->top == MAX - 1;
}

// Function to push an element onto the stack
void push(struct Stack* s, char value) {
    if (isFull(s)) {
        printf("Stack Overflow\n");
        return;
    }
    s->arr[++(s->top)] = value;
}

// Function to pop an element from the stack
char pop(struct Stack* s) {
    if (isEmpty(s)) {
        printf("Stack Underflow\n");
        return -1; // Return an invalid character
    }
    return s->arr[s->top--];
}

// Function to return the precedence of operators
int precedence(char c) {
    if (c == '+' || c == '-') {
        return 1;
    } else if (c == '*' || c == '/') {
        return 2;
    } else {
        return 0;
    }
}

// Function to check if a character is an operand (a number or variable)
int isOperand(char c) {
    return isalpha(c) || isdigit(c); // Operand is either a letter or a digit
}

// Function to convert infix expression to postfix
void infixToPostfix(char* infix, char* postfix) {
    struct Stack s;
    initStack(&s);  // Initialize the stack
    int k = 0;  // Index for postfix string

    for (int i = 0; infix[i] != '\0'; i++) {
        char current = infix[i];

        // If the current character is an operand, add it to the postfix expression
        if (isOperand(current)) {
            postfix[k++] = current;
        }
        // If the current character is '(', push it to the stack
        else if (current == '(') {
            push(&s, current);
        }
        // If the current character is ')', pop from the stack until '(' is encountered
        else if (current == ')') {
            while (!isEmpty(&s) && s.arr[s.top] != '(') {
                postfix[k++] = pop(&s);
            }
            pop(&s);  // Discard '(' from the stack
        }
        // If the current character is an operator
        else {
            while (!isEmpty(&s) && precedence(s.arr[s.top]) >= precedence(current)) {
                postfix[k++] = pop(&s);
            }
            push(&s, current);
        }
    }

    // Pop all remaining operators from the stack
    while (!isEmpty(&s)) {
        postfix[k++] = pop(&s);
    }
    
    postfix[k] = '\0';  // Null-terminate the postfix expression
}

int main() {
    char infix[MAX], postfix[MAX];

    // Input infix expression
    printf("Enter an infix expression: ");
    scanf("%s", infix);

    // Convert infix to postfix
    infixToPostfix(infix, postfix);

    // Output the postfix expression
    printf("Postfix expression: %s\n", postfix);

    return 0;
}


->Evaluation of Postfix Expression. (considering single digit operands)
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

#define MAX 100

// Stack structure
struct Stack {
    int arr[MAX];
    int top;
};

// Function to initialize the stack
void initStack(struct Stack* s) {
    s->top = -1;
}

// Function to check if the stack is empty
int isEmpty(struct Stack* s) {
    return s->top == -1;
}

// Function to push an element onto the stack
void push(struct Stack* s, int value) {
    if (s->top == MAX - 1) {
        printf("Stack Overflow\n");
        return;
    }
    s->arr[++(s->top)] = value;
}

// Function to pop an element from the stack
int pop(struct Stack* s) {
    if (isEmpty(s)) {
        printf("Stack Underflow\n");
        return -1; // Return an invalid value
    }
    return s->arr[s->top--];
}

// Function to evaluate the postfix expression
int evaluatePostfix(char* postfix) {
    struct Stack s;
    initStack(&s);  // Initialize the stack

    for (int i = 0; postfix[i] != '\0'; i++) {
        char current = postfix[i];

        // If the current character is a digit, push it onto the stack
        if (isdigit(current)) {
            push(&s, current - '0');  // Convert char to int (e.g., '5' -> 5)
        }
        // If the current character is an operator
        else if (current == '+' || current == '-' || current == '*' || current == '/') {
            // Pop two operands
            int operand2 = pop(&s);
            int operand1 = pop(&s);

            // Perform the operation and push the result back onto the stack
            switch (current) {
                case '+':
                    push(&s, operand1 + operand2);
                    break;
                case '-':
                    push(&s, operand1 - operand2);
                    break;
                case '*':
                    push(&s, operand1 * operand2);
                    break;
                case '/':
                    if (operand2 != 0) {
                        push(&s, operand1 / operand2);
                    } else {
                        printf("Error: Division by zero\n");
                        return -1; // Return an error code
                    }
                    break;
            }
        }
    }

    // The result will be the only element left in the stack
    return pop(&s);
}

int main() {
    char postfix[MAX];

    // Input postfix expression
    printf("Enter a postfix expression (single-digit operands): ");
    scanf("%s", postfix);

    // Evaluate the postfix expression
    int result = evaluatePostfix(postfix);

    // Output the result
    if (result != -1) {
        printf("The result of the postfix expression is: %d\n", result);
    }

    return 0;
}


->
