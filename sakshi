BFS operations:

#include <stdio.h>
#include <stdlib.h>

// Define the structure for a node in the BST
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Function to insert a new node into the BST
struct Node* insert(struct Node* root, int data) {
    if (root == NULL) {
        return createNode(data);
    }

    if (data < root->data) {
        root->left = insert(root->left, data);
    } else if (data > root->data) {
        root->right = insert(root->right, data);
    }
    
    return root;
}

// Function to perform inorder traversal (Left, Root, Right)
void inorder(struct Node* root) {
    if (root != NULL) {
        inorder(root->left);
        printf("%d ", root->data);
        inorder(root->right);
    }
}

// Function to perform preorder traversal (Root, Left, Right)
void preorder(struct Node* root) {
    if (root != NULL) {
        printf("%d ", root->data);
        preorder(root->left);
        preorder(root->right);
    }
}

// Function to perform postorder traversal (Left, Right, Root)
void postorder(struct Node* root) {
    if (root != NULL) {
        postorder(root->left);
        postorder(root->right);
        printf("%d ", root->data);
    }
}

// Function to search for a value in the BST
struct Node* search(struct Node* root, int key) {
    if (root == NULL || root->data == key) {
        return root;
    }

    if (key < root->data) {
        return search(root->left, key);
    } else {
        return search(root->right, key);
    }
}

// Function to find the node with the minimum value
struct Node* findMin(struct Node* root) {
    while (root->left != NULL) {
        root = root->left;
    }
    return root;
}

// Function to delete a node from the BST
struct Node* delete(struct Node* root, int key) {
    if (root == NULL) {
        return root;
    }

    // If the key to be deleted is smaller than the root's key, go to the left subtree
    if (key < root->data) {
        root->left = delete(root->left, key);
    }
    // If the key to be deleted is larger than the root's key, go to the right subtree
    else if (key > root->data) {
        root->right = delete(root->right, key);
    }
    // If the key to be deleted is the same as the root's key, then this is the node to be deleted
    else {
        // Node with only one child or no child
        if (root->left == NULL) {
            struct Node* temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            struct Node* temp = root->left;
            free(root);
            return temp;
        }

        // Node with two children: Get the inorder successor (smallest in the right subtree)
        struct Node* temp = findMin(root->right);

        // Copy the inorder successor's content to this node
        root->data = temp->data;

        // Delete the inorder successor
        root->right = delete(root->right, temp->data);
    }
    return root;
}

// Function to display menu options
void displayMenu() {
    printf("\nBST Operations Menu:\n");
    printf("1. Insert Node\n");
    printf("2. Inorder Traversal\n");
    printf("3. Preorder Traversal\n");
    printf("4. Postorder Traversal\n");
    printf("5. Search for a Node\n");
    printf("6. Delete Node\n");
    printf("7. Exit\n");
}

int main() {
    struct Node* root = NULL;
    int choice, value;

    do {
        displayMenu();
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch(choice) {
            case 1:
                printf("Enter the value to insert: ");
                scanf("%d", &value);
                root = insert(root, value);
                break;

            case 2:
                printf("Inorder Traversal: ");
                inorder(root);
                printf("\n");
                break;

            case 3:
                printf("Preorder Traversal: ");
                preorder(root);
                printf("\n");
                break;

            case 4:
                printf("Postorder Traversal: ");
                postorder(root);
                printf("\n");
                break;

            case 5:
                printf("Enter value to search: ");
                scanf("%d", &value);
                if (search(root, value) != NULL) {
                    printf("Node with value %d found in the BST.\n", value);
                } else {
                    printf("Node with value %d not found in the BST.\n", value);
                }
                break;

            case 6:
                printf("Enter value to delete: ");
                scanf("%d", &value);
                root = delete(root, value);
                printf("Node with value %d deleted.\n", value);
                break;

            case 7:
                printf("Exiting program...\n");
                break;

            default:
                printf("Invalid choice, please try again.\n");
        }
    } while(choice != 7);

    return 0;
}



-> implement heap sort
#include <stdio.h>
#include <stdlib.h>

// Function to heapify a subtree rooted at index i
// n is the size of the heap
void heapify(int arr[], int n, int i) {
    int largest = i; // Initialize largest as root
    int left = 2 * i + 1; // Left child
    int right = 2 * i + 2; // Right child

    // If left child is larger than root
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }

    // If right child is larger than largest so far
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }

    // If largest is not root, swap it and continue heapifying
    if (largest != i) {
        // Swap arr[i] and arr[largest]
        int temp = arr[i];
        arr[i] = arr[largest];
        arr[largest] = temp;

        // Recursively heapify the affected subtree
        heapify(arr, n, largest);
    }
}

// Function to perform heap sort
void heapSort(int arr[], int n) {
    // Build a max heap
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }

    // One by one extract elements from the heap
    for (int i = n - 1; i >= 1; i--) {
        // Swap the root (maximum element) with the last element
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;

        // Call heapify on the reduced heap
        heapify(arr, i, 0);
    }
}

// Function to print the array
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int n;

    // Take input from the user
    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    printf("Enter the elements:\n");
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    // Perform heap sort
    heapSort(arr, n);

    // Print the sorted array
    printf("Sorted array: ");
    printArray(arr, n);

    return 0;
}


-> implement priority queue using heap
#include <stdio.h>
#include <stdlib.h>

// Structure for a priority queue
struct PriorityQueue {
    int *arr;
    int size;
    int capacity;
};

// Function to create a priority queue
struct PriorityQueue* createPriorityQueue(int capacity) {
    struct PriorityQueue* pq = (struct PriorityQueue*)malloc(sizeof(struct PriorityQueue));
    pq->capacity = capacity;
    pq->size = 0;
    pq->arr = (int*)malloc(capacity * sizeof(int));
    return pq;
}

// Function to swap two elements
void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// Function to heapify a subtree rooted at index i
void heapify(struct PriorityQueue* pq, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    // If left child is larger than root
    if (left < pq->size && pq->arr[left] > pq->arr[largest]) {
        largest = left;
    }

    // If right child is larger than largest so far
    if (right < pq->size && pq->arr[right] > pq->arr[largest]) {
        largest = right;
    }

    // If largest is not root, swap and continue heapifying
    if (largest != i) {
        swap(&pq->arr[i], &pq->arr[largest]);
        heapify(pq, largest);
    }
}

// Function to insert a new element into the priority queue
void insert(struct PriorityQueue* pq, int value) {
    if (pq->size == pq->capacity) {
        printf("Priority Queue is full\n");
        return;
    }

    // Insert the new element at the end
    pq->arr[pq->size] = value;
    int i = pq->size;
    pq->size++;

    // Fix the max-heap property if it's violated
    while (i > 0 && pq->arr[i] > pq->arr[(i - 1) / 2]) {
        swap(&pq->arr[i], &pq->arr[(i - 1) / 2]);
        i = (i - 1) / 2;
    }
}

// Function to extract (remove) the element with the highest priority (max)
int extractMax(struct PriorityQueue* pq) {
    if (pq->size == 0) {
        printf("Priority Queue is empty\n");
        return -1;  // Return a sentinel value indicating empty queue
    }

    // The root contains the maximum element
    int root = pq->arr[0];

    // Move the last element to the root
    pq->arr[0] = pq->arr[pq->size - 1];
    pq->size--;

    // Call heapify to restore the max-heap property
    heapify(pq, 0);

    return root;
}

// Function to get the maximum element from the priority queue (without removing it)
int peek(struct PriorityQueue* pq) {
    if (pq->size == 0) {
        printf("Priority Queue is empty\n");
        return -1;
    }
    return pq->arr[0];
}

// Function to display the contents of the priority queue
void printQueue(struct PriorityQueue* pq) {
    if (pq->size == 0) {
        printf("Priority Queue is empty\n");
        return;
    }

    for (int i = 0; i < pq->size; i++) {
        printf("%d ", pq->arr[i]);
    }
    printf("\n");
}

int main() {
    int capacity;

    printf("Enter the capacity of the priority queue: ");
    scanf("%d", &capacity);

    struct PriorityQueue* pq = createPriorityQueue(capacity);

    int choice, value;
    do {
        printf("\nPriority Queue Operations:\n");
        printf("1. Insert an element\n");
        printf("2. Extract max (dequeue)\n");
        printf("3. Peek (get max)\n");
        printf("4. Display Queue\n");
        printf("5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter the value to insert: ");
                scanf("%d", &value);
                insert(pq, value);
                break;
            case 2:
                value = extractMax(pq);
                if (value != -1) {
                    printf("Extracted max: %d\n", value);
                }
                break;
            case 3:
                value = peek(pq);
                if (value != -1) {
                    printf("Max element: %d\n", value);
                }
                break;
            case 4:
                printf("Priority Queue: ");
                printQueue(pq);
                break;
            case 5:
                printf("Exiting program...\n");
                break;
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 5);

    // Free memory
    free(pq->arr);
    free(pq);

    return 0;
}


-> implement BFS
#include <stdio.h>
#include <stdlib.h>

// Structure for a queue
struct Queue {
    int *arr;
    int front, rear;
    int capacity;
};

// Function to create a queue
struct Queue* createQueue(int capacity) {
    struct Queue* queue = (struct Queue*)malloc(sizeof(struct Queue));
    queue->capacity = capacity;
    queue->front = queue->rear = -1;
    queue->arr = (int*)malloc(capacity * sizeof(int));
    return queue;
}

// Function to check if the queue is empty
int isEmpty(struct Queue* queue) {
    return queue->front == -1;
}

// Function to enqueue an element into the queue
void enqueue(struct Queue* queue, int value) {
    if (queue->rear == queue->capacity - 1) {
        printf("Queue is full\n");
        return;
    }
    if (queue->front == -1) {
        queue->front = 0;
    }
    queue->arr[++queue->rear] = value;
}

// Function to dequeue an element from the queue
int dequeue(struct Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty\n");
        return -1;
    }
    int item = queue->arr[queue->front];
    if (queue->front == queue->rear) {
        queue->front = queue->rear = -1; // Queue is empty after dequeue
    } else {
        queue->front++;
    }
    return item;
}

// Function to implement BFS on a graph
void BFS(int **graph, int n, int start) {
    int visited[n];  // Array to track visited nodes
    struct Queue* queue = createQueue(n);  // Create a queue for BFS

    // Initialize visited array as false (0)
    for (int i = 0; i < n; i++) {
        visited[i] = 0;
    }

    // Enqueue the starting node and mark it as visited
    enqueue(queue, start);
    visited[start] = 1;

    printf("BFS Traversal starting from node %d: ", start);

    // BFS loop
    while (!isEmpty(queue)) {
        int current = dequeue(queue);  // Dequeue a node
        printf("%d ", current);  // Print the node

        // Explore all unvisited neighbors of the current node
        for (int i = 0; i < n; i++) {
            if (graph[current][i] == 1 && !visited[i]) {  // If there's an edge and the node is unvisited
                enqueue(queue, i);
                visited[i] = 1;  // Mark the neighbor as visited
            }
        }
    }

    printf("\n");
}

int main() {
    int n, m;

    // Take the number of nodes and edges as input
    printf("Enter the number of nodes: ");
    scanf("%d", &n);
    printf("Enter the number of edges: ");
    scanf("%d", &m);

    // Dynamically allocate memory for the adjacency matrix
    int **graph = (int **)malloc(n * sizeof(int *));
    for (int i = 0; i < n; i++) {
        graph[i] = (int *)malloc(n * sizeof(int));
    }

    // Initialize the graph (adjacency matrix) with zeros
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            graph[i][j] = 0;
        }
    }

    // Take the edges as input and update the adjacency matrix
    printf("Enter the edges (u v) where u and v are node indices (0-based):\n");
    for (int i = 0; i < m; i++) {
        int u, v;
        scanf("%d %d", &u, &v);
        graph[u][v] = 1;
        graph[v][u] = 1; // Since it's an undirected graph
    }

    // Take the starting node for BFS
    int start;
    printf("Enter the starting node for BFS: ");
    scanf("%d", &start);

    // Call BFS function
    BFS(graph, n, start);

    // Free dynamically allocated memory
    for (int i = 0; i < n; i++) {
        free(graph[i]);
    }
    free(graph);

    return 0;
}


->  Implement hashing 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TABLE_SIZE 10

// Define a structure for a linked list node to store key-value pairs
struct Node {
    int key;
    int value;
    struct Node* next;
};

// Define a structure for the hash table (array of linked lists)
struct HashTable {
    struct Node* table[TABLE_SIZE];
};

// Function to create a new hash table
struct HashTable* createHashTable() {
    struct HashTable* ht = (struct HashTable*)malloc(sizeof(struct HashTable));
    
    // Initialize all table entries to NULL
    for (int i = 0; i < TABLE_SIZE; i++) {
        ht->table[i] = NULL;
    }
    return ht;
}

// Hash function to map a key to an index
int hash(int key) {
    return key % TABLE_SIZE;
}

// Function to insert a key-value pair into the hash table
void insert(struct HashTable* ht, int key, int value) {
    int index = hash(key);  // Calculate the index using the hash function
    
    // Create a new node for the key-value pair
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->key = key;
    newNode->value = value;
    newNode->next = NULL;
    
    // If there's no collision, insert at the empty index
    if (ht->table[index] == NULL) {
        ht->table[index] = newNode;
    } else {
        // If a collision occurs, add the new node to the linked list at this index
        newNode->next = ht->table[index];
        ht->table[index] = newNode;
    }
    printf("Inserted key %d with value %d\n", key, value);
}

// Function to search for a value by key
int search(struct HashTable* ht, int key) {
    int index = hash(key);  // Calculate the index using the hash function
    
    struct Node* temp = ht->table[index];
    while (temp != NULL) {
        if (temp->key == key) {
            return temp->value;  // Return the value if the key is found
        }
        temp = temp->next;
    }
    return -1;  // Return -1 if the key is not found
}

// Function to delete a key-value pair from the hash table
void delete(struct HashTable* ht, int key) {
    int index = hash(key);  // Calculate the index using the hash function
    
    struct Node* temp = ht->table[index];
    struct Node* prev = NULL;
    
    // Traverse the linked list to find the node with the given key
    while (temp != NULL) {
        if (temp->key == key) {
            if (prev == NULL) {
                // The node to be deleted is the first node in the list
                ht->table[index] = temp->next;
            } else {
                // Skip the node to be deleted
                prev->next = temp->next;
            }
            free(temp);  // Free the memory of the deleted node
            printf("Deleted key %d\n", key);
            return;
        }
        prev = temp;
        temp = temp->next;
    }
    
    printf("Key %d not found\n", key);
}

// Function to display the contents of the hash table
void display(struct HashTable* ht) {
    for (int i = 0; i < TABLE_SIZE; i++) {
        struct Node* temp = ht->table[i];
        if (temp != NULL) {
            printf("Index %d: ", i);
            while (temp != NULL) {
                printf("-> (Key: %d, Value: %d) ", temp->key, temp->value);
                temp = temp->next;
            }
            printf("\n");
        }
    }
}

int main() {
    struct HashTable* ht = createHashTable();
    
    int choice, key, value;
    
    do {
        printf("\nMenu:\n");
        printf("1. Insert\n");
        printf("2. Search\n");
        printf("3. Delete\n");
        printf("4. Display Hash Table\n");
        printf("5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        
        switch (choice) {
            case 1:
                printf("Enter key to insert: ");
                scanf("%d", &key);
                printf("Enter value: ");
                scanf("%d", &value);
                insert(ht, key, value);
                break;
                
            case 2:
                printf("Enter key to search: ");
                scanf("%d", &key);
                value = search(ht, key);
                if (value != -1) {
                    printf("Found key %d with value %d\n", key, value);
                } else {
                    printf("Key %d not found\n", key);
                }
                break;
                
            case 3:
                printf("Enter key to delete: ");
                scanf("%d", &key);
                delete(ht, key);
                break;
                
            case 4:
                display(ht);
                break;
                
            case 5:
                printf("Exiting program...\n");
                break;
                
            default:
                printf("Invalid choice!\n");
        }
    } while (choice != 5);
    
    return 0;
}


-> implement DFS
#include <stdio.h>
#include <stdlib.h>

#define MAX_NODES 10

// Function to perform DFS traversal on the graph
void DFS(int graph[MAX_NODES][MAX_NODES], int visited[MAX_NODES], int node, int n) {
    // Mark the current node as visited
    visited[node] = 1;
    printf("%d ", node);

    // Visit all the neighbors of the current node
    for (int i = 0; i < n; i++) {
        if (graph[node][i] == 1 && !visited[i]) {
            DFS(graph, visited, i, n);
        }
    }
}

// Main function
int main() {
    int graph[MAX_NODES][MAX_NODES];
    int visited[MAX_NODES] = {0};  // Initialize visited array to 0
    int n, m, u, v, start;

    // Take the number of nodes and edges as input
    printf("Enter the number of nodes: ");
    scanf("%d", &n);
    printf("Enter the number of edges: ");
    scanf("%d", &m);

    // Initialize the graph with 0 (no edges)
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            graph[i][j] = 0;
        }
    }

    // Take the edges as input and update the graph
    printf("Enter the edges (u v) where u and v are node indices (0-based):\n");
    for (int i = 0; i < m; i++) {
        scanf("%d %d", &u, &v);
        graph[u][v] = 1;
        graph[v][u] = 1;  // For undirected graph
    }

    // Take the starting node for DFS
    printf("Enter the starting node for DFS: ");
    scanf("%d", &start);

    // Perform DFS starting from the given node
    printf("DFS Traversal starting from node %d: ", start);
    DFS(graph, visited, start, n);

    printf("\n");

    return 0;
}

->Binary Search
#include <stdio.h>

// Function for Binary Search
int binarySearch(int arr[], int n, int key) {
    int low = 0, high = n - 1;

    while (low <= high) {
        // Find the middle element
        int mid = low + (high - low) / 2;

        // Check if the key is present at mid
        if (arr[mid] == key) {
            return mid;  // Key found, return index
        }

        // If the key is smaller than mid, search the left half
        if (arr[mid] > key) {
            high = mid - 1;
        }
        // If the key is larger than mid, search the right half
        else {
            low = mid + 1;
        }
    }

    return -1;  // Key not found
}

int main() {
    int n, key;

    // Input number of elements in the array
    printf("Enter number of elements: ");
    scanf("%d", &n);

    int arr[n];

    // Input the sorted array elements
    printf("Enter the sorted array elements:\n");
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    // Input the key to be searched
    printf("Enter the key to search: ");
    scanf("%d", &key);

    // Call binarySearch function
    int result = binarySearch(arr, n, key);

    // Output the result
    if (result == -1) {
        printf("Element not found in the array\n");
    } else {
        printf("Element found at index %d\n", result);
    }

    return 0;
}


->bubble sort
#include <stdio.h>

// Function to perform Bubble Sort
void bubbleSort(int arr[], int n) {
    int temp;
    // Traverse through all array elements
    for (int i = 0; i < n-1; i++) {
        // Last i elements are already in place
        for (int j = 0; j < n-i-1; j++) {
            // Swap if the element found is greater than the next element
            if (arr[j] > arr[j+1]) {
                temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}

// Function to print the array
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr)/sizeof(arr[0]);

    printf("Original array: \n");
    printArray(arr, n);

    bubbleSort(arr, n);

    printf("Sorted array: \n");
    printArray(arr, n);

    return 0;
}

-> insertion sort
#include <stdio.h>

// Function to perform Insertion Sort
void insertionSort(int arr[], int n) {
    int key, j;
    // Traverse through 1 to n-1
    for (int i = 1; i < n; i++) {
        key = arr[i];
        j = i - 1;

        // Move elements of arr[0..i-1], that are greater than key,
        // to one position ahead of their current position
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}

// Function to print the array
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int arr[] = {12, 11, 13, 5, 6};
    int n = sizeof(arr)/sizeof(arr[0]);

    printf("Original array: \n");
    printArray(arr, n);

    insertionSort(arr, n);

    printf("Sorted array: \n");
    printArray(arr, n);

    return 0;
}

->selection sort
#include <stdio.h>

// Function to perform Selection Sort
void selectionSort(int arr[], int n) {
    int minIndex, temp;
    // One by one move the boundary of unsorted subarray
    for (int i = 0; i < n-1; i++) {
        minIndex = i;
        
        // Find the minimum element in the unsorted array
        for (int j = i+1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        
        // Swap the found minimum element with the first element
        temp = arr[minIndex];
        arr[minIndex] = arr[i];
        arr[i] = temp;
    }
}

// Function to print the array
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int arr[] = {64, 25, 12, 22, 11};
    int n = sizeof(arr)/sizeof(arr[0]);

    printf("Original array: \n");
    printArray(arr, n);

    selectionSort(arr, n);

    printf("Sorted array: \n");
    printArray(arr, n);

    return 0;
}


-> linear search
#include <stdio.h>

// Function for Linear Search
int linearSearch(int arr[], int n, int key) {
    for (int i = 0; i < n; i++) {
        // If the key is found, return the index
        if (arr[i] == key) {
            return i;
        }
    }
    // If the key is not found, return -1
    return -1;
}

int main() {
    int n, key;

    // Input the number of elements
    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    // Input the array elements
    printf("Enter the elements of the array:\n");
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    // Input the key to search for
    printf("Enter the key to search: ");
    scanf("%d", &key);

    // Call linearSearch function
    int result = linearSearch(arr, n, key);

    // Output the result
    if (result == -1) {
        printf("Element not found in the array\n");
    } else {
        printf("Element found at index %d\n", result);
    }

    return 0;
}


-> interpolation search
#include <stdio.h>

// Function for Interpolation Search
int interpolationSearch(int arr[], int n, int key) {
    int low = 0, high = n - 1;

    // Loop to perform search
    while (low <= high && key >= arr[low] && key <= arr[high]) {
        // Calculate the probe position using the interpolation formula
        int pos = low + ((key - arr[low]) * (high - low)) / (arr[high] - arr[low]);

        // Check if the key is present at the probe position
        if (arr[pos] == key) {
            return pos;
        }

        // If key is larger, search the right half
        if (arr[pos] < key) {
            low = pos + 1;
        }
        // If key is smaller, search the left half
        else {
            high = pos - 1;
        }
    }

    // If the key is not found, return -1
    return -1;
}

int main() {
    int n, key;

    // Input the number of elements
    printf("Enter the number of elements: ");
    scanf("%d", &n);

    int arr[n];

    // Input the array elements
    printf("Enter the sorted elements of the array:\n");
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    // Input the key to search for
    printf("Enter the key to search: ");
    scanf("%d", &key);

    // Call interpolationSearch function
    int result = interpolationSearch(arr, n, key);

    // Output the result
    if (result == -1) {
        printf("Element not found in the array\n");
    } else {
        printf("Element found at index %d\n", result);
    }

    return 0;
}


->Implement the quick Sort
#include <stdio.h>

// Function to swap two elements
void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// Partition function to rearrange elements based on pivot
int partition(int arr[], int low, int high) {
    int pivot = arr[high];  // pivot element
    int i = (low - 1);  // Index of smaller element

    for (int j = low; j < high; j++) {
        // If current element is smaller than the pivot, swap it to the left of the pivot
        if (arr[j] < pivot) {
            i++;
            swap(&arr[i], &arr[j]);
        }
    }
    // Place the pivot element in its correct position
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);  // Return the partition index
}

// Quick Sort function
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        // Partitioning index
        int pi = partition(arr, low, high);

        // Recursively sort the left and right sub-arrays
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

// Function to print the array
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int n;

    // Input number of elements
    printf("Enter number of elements: ");
    scanf("%d", &n);

    int arr[n];

    // Input array elements
    printf("Enter the elements of the array:\n");
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    // Call quickSort function
    quickSort(arr, 0, n - 1);

    // Print sorted array
    printf("Sorted array: \n");
    printArray(arr, n);

    return 0;
}

-> Implement radix sort
#include <stdio.h>

// Function to perform Counting Sort based on the digit represented by exp (1s, 10s, 100s, etc.)
void countingSort(int arr[], int n, int exp) {
    int output[n];  // Output array
    int count[10] = {0};  // Count array for digits (0-9)

    // Store count of occurrences of (arr[i] / exp) % 10
    for (int i = 0; i < n; i++) {
        count[(arr[i] / exp) % 10]++;
    }

    // Update count[i] so that it contains the actual position of this digit in output[]
    for (int i = 1; i < 10; i++) {
        count[i] += count[i - 1];
    }

    // Build the output array
    for (int i = n - 1; i >= 0; i--) {
        output[count[(arr[i] / exp) % 10] - 1] = arr[i];
        count[(arr[i] / exp) % 10]--;
    }

    // Copy the output array to arr[], so that arr[] now contains sorted numbers based on the current digit
    for (int i = 0; i < n; i++) {
        arr[i] = output[i];
    }
}

// Function to implement Radix Sort
void radixSort(int arr[], int n) {
    // Find the maximum number to know the number of digits
    int max = arr[0];
    for (int i = 1; i < n; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }

    // Perform counting sort for every digit. The exp is 10^i where i is the current digit number.
    for (int exp = 1; max / exp > 0; exp *= 10) {
        countingSort(arr, n, exp);
    }
}

// Function to print the array
void printArray(int arr[], int n) {
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int n;

    // Input the number of elements
    printf("Enter number of elements: ");
    scanf("%d", &n);

    int arr[n];

    // Input the elements of the array
    printf("Enter the elements of the array:\n");
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    // Perform Radix Sort
    radixSort(arr, n);

    // Print the sorted array
    printf("Sorted array: \n");
    printArray(arr, n);

    return 0;
}


->Implement Merge Sort
#include <stdio.h>

// Function to merge two halves of the array into a sorted array
void merge(int arr[], int left, int mid, int right) {
    // Calculate the size of the two sub-arrays
    int n1 = mid - left + 1;
    int n2 = right - mid;

    // Temporary arrays for the left and right sub-arrays
    int L[n1], R[n2];

    // Copy data to temporary arrays L[] and R[]
    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];

    // Merge the temporary arrays back into the original array
    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // Copy the remaining elements of L[], if any
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    // Copy the remaining elements of R[], if any
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

// Function to implement Merge Sort
void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        // Find the middle point
        int mid = left + (right - left) / 2;

        // Recursively sort the first and second halves
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);

        // Merge the two sorted halves
        merge(arr, left, mid, right);
    }
}

// Function to print the array
void printArray(int arr[], int n) {
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int n;

    // Input the number of elements
    printf("Enter number of elements: ");
    scanf("%d", &n);

    int arr[n];

    // Input the elements of the array
    printf("Enter the elements of the array:\n");
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    // Perform Merge Sort
    mergeSort(arr, 0, n - 1);

    // Print the sorted array
    printf("Sorted array: \n");
    printArray(arr, n);

    return 0;
}


->Implement Shell Sort
#include <stdio.h>

// Function to perform Shell Sort
void shellSort(int arr[], int n) {
    // Start with a large gap, then reduce it
    for (int gap = n / 2; gap > 0; gap /= 2) {
        // Perform a gapped Insertion Sort for this gap size
        for (int i = gap; i < n; i++) {
            int temp = arr[i];
            int j = i;

            // Shift elements of arr[0..i-gap], that are greater than temp, to one position ahead
            while (j >= gap && arr[j - gap] > temp) {
                arr[j] = arr[j - gap];
                j -= gap;
            }
            arr[j] = temp;
        }
    }
}

// Function to print the array
void printArray(int arr[], int n) {
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int n;

    // Input the number of elements
    printf("Enter number of elements: ");
    scanf("%d", &n);

    int arr[n];

    // Input the elements of the array
    printf("Enter the elements of the array:\n");
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    // Perform Shell Sort
    shellSort(arr, n);

    // Print the sorted array
    printf("Sorted array: \n");
    printArray(arr, n);

    return 0;
}


-> Implementation of Linear Queue using array
#include <stdio.h>
#include <stdlib.h>

#define MAX 5  // Define maximum size of the queue

// Structure to represent a queue
struct Queue {
    int arr[MAX];  // Array to store the elements of the queue
    int front;     // Front of the queue
    int rear;      // Rear of the queue
};

// Function to initialize the queue
void initQueue(struct Queue* q) {
    q->front = -1;
    q->rear = -1;
}

// Function to check if the queue is full
int isFull(struct Queue* q) {
    if (q->rear == MAX - 1) {
        return 1;  // Queue is full
    }
    return 0;
}

// Function to check if the queue is empty
int isEmpty(struct Queue* q) {
    if (q->front == -1 || q->front > q->rear) {
        return 1;  // Queue is empty
    }
    return 0;
}

// Function to add an element to the queue (Enqueue)
void enqueue(struct Queue* q, int value) {
    if (isFull(q)) {
        printf("Queue is full. Cannot enqueue %d\n", value);
    } else {
        if (q->front == -1) {
            q->front = 0;  // Set front to 0 when the first element is added
        }
        q->rear++;
        q->arr[q->rear] = value;  // Insert the element at the rear
        printf("Enqueued %d\n", value);
    }
}

// Function to remove an element from the queue (Dequeue)
void dequeue(struct Queue* q) {
    if (isEmpty(q)) {
        printf("Queue is empty. Cannot dequeue.\n");
    } else {
        printf("Dequeued %d\n", q->arr[q->front]);
        q->front++;  // Move the front pointer to the next element
    }
}

// Function to get the front element of the queue
int front(struct Queue* q) {
    if (isEmpty(q)) {
        printf("Queue is empty.\n");
        return -1;
    } else {
        return q->arr[q->front];
    }
}

// Function to get the rear element of the queue
int rear(struct Queue* q) {
    if (isEmpty(q)) {
        printf("Queue is empty.\n");
        return -1;
    } else {
        return q->arr[q->rear];
    }
}

// Function to display the elements of the queue
void displayQueue(struct Queue* q) {
    if (isEmpty(q)) {
        printf("Queue is empty.\n");
    } else {
        printf("Queue elements: ");
        for (int i = q->front; i <= q->rear; i++) {
            printf("%d ", q->arr[i]);
        }
        printf("\n");
    }
}

int main() {
    struct Queue q;
    initQueue(&q);  // Initialize the queue

    int choice, value;

    // Menu-driven interface
    do {
        printf("\nQueue Operations Menu:\n");
        printf("1. Enqueue\n");
        printf("2. Dequeue\n");
        printf("3. Front\n");
        printf("4. Rear\n");
        printf("5. Display Queue\n");
        printf("6. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:  // Enqueue
                printf("Enter value to enqueue: ");
                scanf("%d", &value);
                enqueue(&q, value);
                break;
            case 2:  // Dequeue
                dequeue(&q);
                break;
            case 3:  // Front
                value = front(&q);
                if (value != -1) {
                    printf("Front element: %d\n", value);
                }
                break;
            case 4:  // Rear
                value = rear(&q);
                if (value != -1) {
                    printf("Rear element: %d\n", value);
                }
                break;
            case 5:  // Display
                displayQueue(&q);
                break;
            case 6:  // Exit
                printf("Exiting program.\n");
                break;
            default:
                printf("Invalid choice, please try again.\n");
        }
    } while (choice != 6);

    return 0;
}


->Implementation of Circular Queue using array
#include <stdio.h>
#include <stdlib.h>

#define MAX 5  // Define maximum size of the queue

// Structure to represent a queue
struct Queue {
    int arr[MAX];  // Array to store queue elements
    int front;     // Front of the queue
    int rear;      // Rear of the queue
};

// Function to initialize the queue
void initQueue(struct Queue* q) {
    q->front = -1;
    q->rear = -1;
}

// Function to check if the queue is full
int isFull(struct Queue* q) {
    if ((q->rear + 1) % MAX == q->front) {
        return 1;  // Queue is full
    }
    return 0;
}

// Function to check if the queue is empty
int isEmpty(struct Queue* q) {
    if (q->front == -1) {
        return 1;  // Queue is empty
    }
    return 0;
}

// Function to add an element to the queue (Enqueue)
void enqueue(struct Queue* q, int value) {
    if (isFull(q)) {
        printf("Queue is full. Cannot enqueue %d\n", value);
    } else {
        if (q->front == -1) {
            q->front = 0;  // Set front to 0 when the first element is added
        }
        q->rear = (q->rear + 1) % MAX;  // Move rear to the next position, wrapping around if needed
        q->arr[q->rear] = value;  // Insert the element at the rear
        printf("Enqueued %d\n", value);
    }
}

// Function to remove an element from the queue (Dequeue)
void dequeue(struct Queue* q) {
    if (isEmpty(q)) {
        printf("Queue is empty. Cannot dequeue.\n");
    } else {
        printf("Dequeued %d\n", q->arr[q->front]);
        if (q->front == q->rear) {
            // If the queue has only one element, reset the queue after dequeue
            q->front = -1;
            q->rear = -1;
        } else {
            q->front = (q->front + 1) % MAX;  // Move front to the next position, wrapping around if needed
        }
    }
}

// Function to get the front element of the queue
int front(struct Queue* q) {
    if (isEmpty(q)) {
        printf("Queue is empty.\n");
        return -1;
    } else {
        return q->arr[q->front];
    }
}

// Function to get the rear element of the queue
int rear(struct Queue* q) {
    if (isEmpty(q)) {
        printf("Queue is empty.\n");
        return -1;
    } else {
        return q->arr[q->rear];
    }
}

// Function to display the elements of the queue
void displayQueue(struct Queue* q) {
    if (isEmpty(q)) {
        printf("Queue is empty.\n");
    } else {
        printf("Queue elements: ");
        int i = q->front;
        while (i != q->rear) {
            printf("%d ", q->arr[i]);
            i = (i + 1) % MAX;  // Wrap around if needed
        }
        printf("%d\n", q->arr[q->rear]);  // Print the last element (rear)
    }
}

int main() {
    struct Queue q;
    initQueue(&q);  // Initialize the queue

    int choice, value;

    // Menu-driven interface
    do {
        printf("\nCircular Queue Operations Menu:\n");
        printf("1. Enqueue\n");
        printf("2. Dequeue\n");
        printf("3. Front\n");
        printf("4. Rear\n");
        printf("5. Display Queue\n");
        printf("6. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:  // Enqueue
                printf("Enter value to enqueue: ");
                scanf("%d", &value);
                enqueue(&q, value);
                break;
            case 2:  // Dequeue
                dequeue(&q);
                break;
            case 3:  // Front
                value = front(&q);
                if (value != -1) {
                    printf("Front element: %d\n", value);
                }
                break;
            case 4:  // Rear
                value = rear(&q);
                if (value != -1) {
                    printf("Rear element: %d\n", value);
                }
                break;
            case 5:  // Display
                displayQueue(&q);
                break;
            case 6:  // Exit
                printf("Exiting program.\n");
                break;
            default:
                printf("Invalid choice, please try again.\n");
        }
    } while (choice != 6);

    return 0;
}


->Implementation of Circular DE Queue using array
#include <stdio.h>
#include <stdlib.h>

#define MAX 5  // Define maximum size of the deque

// Structure to represent a circular deque
struct Deque {
    int arr[MAX];  // Array to store deque elements
    int front;     // Front index of the deque
    int rear;      // Rear index of the deque
};

// Function to initialize the deque
void initDeque(struct Deque* dq) {
    dq->front = -1;
    dq->rear = -1;
}

// Function to check if the deque is full
int isFull(struct Deque* dq) {
    if ((dq->front == 0 && dq->rear == MAX - 1) || (dq->rear == (dq->front - 1) % (MAX - 1))) {
        return 1;  // Deque is full
    }
    return 0;
}

// Function to check if the deque is empty
int isEmpty(struct Deque* dq) {
    if (dq->front == -1) {
        return 1;  // Deque is empty
    }
    return 0;
}

// Function to insert an element at the front of the deque
void insertFront(struct Deque* dq, int value) {
    if (isFull(dq)) {
        printf("Deque is full. Cannot insert %d at front.\n", value);
    } else {
        if (dq->front == -1) {
            dq->front = dq->rear = 0;  // If deque is empty, set both front and rear to 0
        } else if (dq->front == 0) {
            dq->front = MAX - 1;  // Wrap around the front index to the last element
        } else {
            dq->front--;  // Decrease front index
        }
        dq->arr[dq->front] = value;  // Insert the element at the front
        printf("Inserted %d at front.\n", value);
    }
}

// Function to insert an element at the rear of the deque
void insertRear(struct Deque* dq, int value) {
    if (isFull(dq)) {
        printf("Deque is full. Cannot insert %d at rear.\n", value);
    } else {
        if (dq->front == -1) {
            dq->front = dq->rear = 0;  // If deque is empty, set both front and rear to 0
        } else if (dq->rear == MAX - 1) {
            dq->rear = 0;  // Wrap around the rear index to the first element
        } else {
            dq->rear++;  // Increase the rear index
        }
        dq->arr[dq->rear] = value;  // Insert the element at the rear
        printf("Inserted %d at rear.\n", value);
    }
}

// Function to delete an element from the front of the deque
void deleteFront(struct Deque* dq) {
    if (isEmpty(dq)) {
        printf("Deque is empty. Cannot delete from front.\n");
    } else {
        printf("Deleted %d from front.\n", dq->arr[dq->front]);
        if (dq->front == dq->rear) {
            dq->front = dq->rear = -1;  // If there's only one element, reset both pointers
        } else if (dq->front == MAX - 1) {
            dq->front = 0;  // Wrap around the front index to the beginning
        } else {
            dq->front++;  // Move the front pointer
        }
    }
}

// Function to delete an element from the rear of the deque
void deleteRear(struct Deque* dq) {
    if (isEmpty(dq)) {
        printf("Deque is empty. Cannot delete from rear.\n");
    } else {
        printf("Deleted %d from rear.\n", dq->arr[dq->rear]);
        if (dq->front == dq->rear) {
            dq->front = dq->rear = -1;  // If there's only one element, reset both pointers
        } else if (dq->rear == 0) {
            dq->rear = MAX - 1;  // Wrap around the rear index to the last element
        } else {
            dq->rear--;  // Move the rear pointer
        }
    }
}

// Function to get the front element of the deque
int getFront(struct Deque* dq) {
    if (isEmpty(dq)) {
        printf("Deque is empty.\n");
        return -1;
    }
    return dq->arr[dq->front];
}

// Function to get the rear element of the deque
int getRear(struct Deque* dq) {
    if (isEmpty(dq)) {
        printf("Deque is empty.\n");
        return -1;
    }
    return dq->arr[dq->rear];
}

// Function to display the elements of the deque
void displayDeque(struct Deque* dq) {
    if (isEmpty(dq)) {
        printf("Deque is empty.\n");
    } else {
        printf("Deque elements: ");
        int i = dq->front;
        while (i != dq->rear) {
            printf("%d ", dq->arr[i]);
            i = (i + 1) % MAX;  // Wrap around if needed
        }
        printf("%d\n", dq->arr[dq->rear]);  // Print the last element
    }
}

int main() {
    struct Deque dq;
    initDeque(&dq);  // Initialize the deque

    int choice, value;

    // Menu-driven interface
    do {
        printf("\nCircular Deque Operations Menu:\n");
        printf("1. Insert Front\n");
        printf("2. Insert Rear\n");
        printf("3. Delete Front\n");
        printf("4. Delete Rear\n");
        printf("5. Get Front\n");
        printf("6. Get Rear\n");
        printf("7. Display Deque\n");
        printf("8. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:  // Insert Front
                printf("Enter value to insert at front: ");
                scanf("%d", &value);
                insertFront(&dq, value);
                break;
            case 2:  // Insert Rear
                printf("Enter value to insert at rear: ");
                scanf("%d", &value);
                insertRear(&dq, value);
                break;
            case 3:  // Delete Front
                deleteFront(&dq);
                break;
            case 4:  // Delete Rear
                deleteRear(&dq);
                break;
            case 5:  // Get Front
                value = getFront(&dq);
                if (value != -1) {
                    printf("Front element: %d\n", value);
                }
                break;
            case 6:  // Get Rear
                value = getRear(&dq);
                if (value != -1) {
                    printf("Rear element: %d\n", value);
                }
                break;
            case 7:  // Display Deque
                displayDeque(&dq);
                break;
            case 8:  // Exit
                printf("Exiting program.\n");
                break;
            default:
                printf("Invalid choice, please try again.\n");
        }
    } while (choice != 8);

    return 0;
}


->Implementation of Stack using array
#include <stdio.h>
#include <stdlib.h>

#define MAX 5  // Define maximum size of the stack

// Structure to represent a stack
struct Stack {
    int arr[MAX];  // Array to store stack elements
    int top;       // Index of the top element in the stack
};

// Function to initialize the stack
void initStack(struct Stack* s) {
    s->top = -1;  // Stack is empty initially
}

// Function to check if the stack is full
int isFull(struct Stack* s) {
    if (s->top == MAX - 1) {
        return 1;  // Stack is full
    }
    return 0;
}

// Function to check if the stack is empty
int isEmpty(struct Stack* s) {
    if (s->top == -1) {
        return 1;  // Stack is empty
    }
    return 0;
}

// Function to push an element onto the stack
void push(struct Stack* s, int value) {
    if (isFull(s)) {
        printf("Stack is full. Cannot push %d\n", value);
    } else {
        s->arr[++(s->top)] = value;  // Increment top and insert the element
        printf("Pushed %d onto stack\n", value);
    }
}

// Function to pop an element from the stack
void pop(struct Stack* s) {
    if (isEmpty(s)) {
        printf("Stack is empty. Cannot pop.\n");
    } else {
        printf("Popped %d from stack\n", s->arr[s->top]);
        s->top--;  // Decrease top to remove the element
    }
}

// Function to return the top element of the stack without removing it
int peek(struct Stack* s) {
    if (isEmpty(s)) {
        printf("Stack is empty.\n");
        return -1;  // Return a sentinel value for empty stack
    }
    return s->arr[s->top];
}

// Function to display the elements of the stack
void display(struct Stack* s) {
    if (isEmpty(s)) {
        printf("Stack is empty.\n");
    } else {
        printf("Stack elements: ");
        for (int i = s->top; i >= 0; i--) {
            printf("%d ", s->arr[i]);
        }
        printf("\n");
    }
}

int main() {
    struct Stack s;
    initStack(&s);  // Initialize the stack

    int choice, value;

    // Menu-driven interface for stack operations
    do {
        printf("\nStack Operations Menu:\n");
        printf("1. Push\n");
        printf("2. Pop\n");
        printf("3. Peek/Top\n");
        printf("4. Display Stack\n");
        printf("5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:  // Push
                printf("Enter value to push: ");
                scanf("%d", &value);
                push(&s, value);
                break;
            case 2:  // Pop
                pop(&s);
                break;
            case 3:  // Peek/Top
                value = peek(&s);
                if (value != -1) {
                    printf("Top element: %d\n", value);
                }
                break;
            case 4:  // Display
                display(&s);
                break;
            case 5:  // Exit
                printf("Exiting program.\n");
                break;
            default:
                printf("Invalid choice, please try again.\n");
        }
    } while (choice != 5);

    return 0;
}


->Parenthesis check using stack
#include <stdio.h>
#include <stdlib.h>

#define MAX 100  // Define maximum size of the stack

// Stack structure
struct Stack {
    char arr[MAX];  // Array to store stack elements
    int top;        // Index of the top element in the stack
};

// Function to initialize the stack
void initStack(struct Stack* s) {
    s->top = -1;  // Set top to -1 to indicate an empty stack
}

// Function to check if the stack is empty
int isEmpty(struct Stack* s) {
    return s->top == -1;
}

// Function to check if the stack is full
int isFull(struct Stack* s) {
    return s->top == MAX - 1;
}

// Function to push an element onto the stack
void push(struct Stack* s, char value) {
    if (isFull(s)) {
        printf("Stack is full\n");
        return;
    }
    s->arr[++(s->top)] = value;  // Increment top and push value
}

// Function to pop an element from the stack
char pop(struct Stack* s) {
    if (isEmpty(s)) {
        printf("Stack is empty\n");
        return -1;  // Return -1 if stack is empty
    }
    return s->arr[s->top--];  // Pop the top element and decrease top
}

// Function to check if two characters are matching parentheses
int isMatchingPair(char opening, char closing) {
    if (opening == '(' && closing == ')') {
        return 1;
    } else if (opening == '[' && closing == ']') {
        return 1;
    } else if (opening == '{' && closing == '}') {
        return 1;
    }
    return 0;
}

// Function to check if the parentheses in the expression are balanced
int checkParenthesesBalance(char* expr) {
    struct Stack s;
    initStack(&s);  // Initialize the stack

    // Traverse the expression character by character
    for (int i = 0; expr[i] != '\0'; i++) {
        char currentChar = expr[i];

        // If the current character is an opening parenthesis, push it onto the stack
        if (currentChar == '(' || currentChar == '[' || currentChar == '{') {
            push(&s, currentChar);
        }
        // If the current character is a closing parenthesis
        else if (currentChar == ')' || currentChar == ']' || currentChar == '}') {
            // If the stack is empty or the top of the stack does not match
            if (isEmpty(&s) || !isMatchingPair(pop(&s), currentChar)) {
                return 0;  // Unbalanced parentheses
            }
        }
    }

    // If the stack is empty, the parentheses are balanced, else unbalanced
    return isEmpty(&s);
}

int main() {
    char expr[MAX];

    // Input the expression from the user
    printf("Enter an expression: ");
    scanf("%s", expr);

    // Check if the expression has balanced parentheses
    if (checkParenthesesBalance(expr)) {
        printf("The parentheses are balanced.\n");
    } else {
        printf("The parentheses are unbalanced.\n");
    }

    return 0;
}


->Solving the following problems using recursion:
a) Tower of Hanoii
#include <stdio.h>

// Function to solve the Tower of Hanoi problem
// n: number of disks
// source: source rod
// destination: destination rod
// auxiliary: auxiliary rod
void towerOfHanoi(int n, char source, char destination, char auxiliary) {
    // Base case: If there's only one disk to move
    if (n == 1) {
        printf("Move disk 1 from rod %c to rod %c\n", source, destination);
        return;
    }

    // Move top n-1 disks from source to auxiliary
    towerOfHanoi(n - 1, source, auxiliary, destination);

    // Move nth disk from source to destination
    printf("Move disk %d from rod %c to rod %c\n", n, source, destination);

    // Move n-1 disks from auxiliary to destination
    towerOfHanoi(n - 1, auxiliary, destination, source);
}

int main() {
    int n;

    // Input the number of disks
    printf("Enter the number of disks: ");
    scanf("%d", &n);

    // Call the Tower of Hanoi function
    // The rods are labeled 'A', 'B', and 'C'
    towerOfHanoi(n, 'A', 'C', 'B');

    return 0;
}


->Solving the following problems using recursion:
b) Fibonacii series printing 
#include <stdio.h>

// Recursive function to calculate the nth Fibonacci number
int fibonacci(int n) {
    // Base case: Fibonacci(0) = 0 and Fibonacci(1) = 1
    if (n == 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    } else {
        // Recursive case: Fibonacci(n) = Fibonacci(n-1) + Fibonacci(n-2)
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

// Function to print the Fibonacci series up to n
void printFibonacciSeries(int n) {
    for (int i = 0; i < n; i++) {
        printf("%d ", fibonacci(i));
    }
    printf("\n");
}

int main() {
    int n;

    // Input the number of terms to print in the Fibonacci series
    printf("Enter the number of terms in the Fibonacci series: ");
    scanf("%d", &n);

    // Print the Fibonacci series up to n terms
    printFibonacciSeries(n);

    return 0;
}


->Solving the following problems using recursion:
(c) finding gcd of two numbers
#include <stdio.h>

// Recursive function to find GCD of two numbers
int gcd(int a, int b) {
    // Base case: if b is 0, return a
    if (b == 0) {
        return a;
    }
    // Recursive case: GCD(a, b) = GCD(b, a % b)
    return gcd(b, a % b);
}

int main() {
    int a, b;

    // Input two numbers
    printf("Enter two numbers: ");
    scanf("%d %d", &a, &b);

    // Find and display the GCD
    printf("The GCD of %d and %d is: %d\n", a, b, gcd(a, b));

    return 0;
}


->Infix Expression to Postfix Expression Conversion
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

#define MAX 100

// Stack structure
struct Stack {
    char arr[MAX];
    int top;
};

// Function to initialize the stack
void initStack(struct Stack* s) {
    s->top = -1;
}

// Function to check if the stack is empty
int isEmpty(struct Stack* s) {
    return s->top == -1;
}

// Function to check if the stack is full
int isFull(struct Stack* s) {
    return s->top == MAX - 1;
}

// Function to push an element onto the stack
void push(struct Stack* s, char value) {
    if (isFull(s)) {
        printf("Stack Overflow\n");
        return;
    }
    s->arr[++(s->top)] = value;
}

// Function to pop an element from the stack
char pop(struct Stack* s) {
    if (isEmpty(s)) {
        printf("Stack Underflow\n");
        return -1; // Return an invalid character
    }
    return s->arr[s->top--];
}

// Function to return the precedence of operators
int precedence(char c) {
    if (c == '+' || c == '-') {
        return 1;
    } else if (c == '*' || c == '/') {
        return 2;
    } else {
        return 0;
    }
}

// Function to check if a character is an operand (a number or variable)
int isOperand(char c) {
    return isalpha(c) || isdigit(c); // Operand is either a letter or a digit
}

// Function to convert infix expression to postfix
void infixToPostfix(char* infix, char* postfix) {
    struct Stack s;
    initStack(&s);  // Initialize the stack
    int k = 0;  // Index for postfix string

    for (int i = 0; infix[i] != '\0'; i++) {
        char current = infix[i];

        // If the current character is an operand, add it to the postfix expression
        if (isOperand(current)) {
            postfix[k++] = current;
        }
        // If the current character is '(', push it to the stack
        else if (current == '(') {
            push(&s, current);
        }
        // If the current character is ')', pop from the stack until '(' is encountered
        else if (current == ')') {
            while (!isEmpty(&s) && s.arr[s.top] != '(') {
                postfix[k++] = pop(&s);
            }
            pop(&s);  // Discard '(' from the stack
        }
        // If the current character is an operator
        else {
            while (!isEmpty(&s) && precedence(s.arr[s.top]) >= precedence(current)) {
                postfix[k++] = pop(&s);
            }
            push(&s, current);
        }
    }

    // Pop all remaining operators from the stack
    while (!isEmpty(&s)) {
        postfix[k++] = pop(&s);
    }
    
    postfix[k] = '\0';  // Null-terminate the postfix expression
}

int main() {
    char infix[MAX], postfix[MAX];

    // Input infix expression
    printf("Enter an infix expression: ");
    scanf("%s", infix);

    // Convert infix to postfix
    infixToPostfix(infix, postfix);

    // Output the postfix expression
    printf("Postfix expression: %s\n", postfix);

    return 0;
}


->Evaluation of Postfix Expression. (considering single digit operands)
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

#define MAX 100

// Stack structure
struct Stack {
    int arr[MAX];
    int top;
};

// Function to initialize the stack
void initStack(struct Stack* s) {
    s->top = -1;
}

// Function to check if the stack is empty
int isEmpty(struct Stack* s) {
    return s->top == -1;
}

// Function to push an element onto the stack
void push(struct Stack* s, int value) {
    if (s->top == MAX - 1) {
        printf("Stack Overflow\n");
        return;
    }
    s->arr[++(s->top)] = value;
}

// Function to pop an element from the stack
int pop(struct Stack* s) {
    if (isEmpty(s)) {
        printf("Stack Underflow\n");
        return -1; // Return an invalid value
    }
    return s->arr[s->top--];
}

// Function to evaluate the postfix expression
int evaluatePostfix(char* postfix) {
    struct Stack s;
    initStack(&s);  // Initialize the stack

    for (int i = 0; postfix[i] != '\0'; i++) {
        char current = postfix[i];

        // If the current character is a digit, push it onto the stack
        if (isdigit(current)) {
            push(&s, current - '0');  // Convert char to int (e.g., '5' -> 5)
        }
        // If the current character is an operator
        else if (current == '+' || current == '-' || current == '*' || current == '/') {
            // Pop two operands
            int operand2 = pop(&s);
            int operand1 = pop(&s);

            // Perform the operation and push the result back onto the stack
            switch (current) {
                case '+':
                    push(&s, operand1 + operand2);
                    break;
                case '-':
                    push(&s, operand1 - operand2);
                    break;
                case '*':
                    push(&s, operand1 * operand2);
                    break;
                case '/':
                    if (operand2 != 0) {
                        push(&s, operand1 / operand2);
                    } else {
                        printf("Error: Division by zero\n");
                        return -1; // Return an error code
                    }
                    break;
            }
        }
    }

    // The result will be the only element left in the stack
    return pop(&s);
}

int main() {
    char postfix[MAX];

    // Input postfix expression
    printf("Enter a postfix expression (single-digit operands): ");
    scanf("%s", postfix);

    // Evaluate the postfix expression
    int result = evaluatePostfix(postfix);

    // Output the result
    if (result != -1) {
        printf("The result of the postfix expression is: %d\n", result);
    }
return 0;
}


->Write functions to add two polynomials, to multiply two polynomials, taking input and displaying polynomials in correct format
#include <stdio.h>
#include <stdlib.h>

// Structure to represent a polynomial term
struct Term {
    int coeff; // Coefficient
    int power; // Power of x
};

// Function to add two polynomials
void addPolynomials(struct Term poly1[], int n1, struct Term poly2[], int n2) {
    int i = 0, j = 0, k = 0;
    struct Term result[n1 + n2];

    while (i < n1 && j < n2) {
        if (poly1[i].power == poly2[j].power) {
            result[k].coeff = poly1[i].coeff + poly2[j].coeff;
            result[k].power = poly1[i].power;
            i++;
            j++;
        } else if (poly1[i].power > poly2[j].power) {
            result[k] = poly1[i];
            i++;
        } else {
            result[k] = poly2[j];
            j++;
        }
        k++;
    }

    while (i < n1) {
        result[k] = poly1[i];
        i++;
        k++;
    }

    while (j < n2) {
        result[k] = poly2[j];
        j++;
        k++;
    }

    printf("Result of addition: ");
    for (int l = 0; l < k; l++) {
        if (l > 0 && result[l].coeff > 0)
            printf("+");
        printf("%dx^%d ", result[l].coeff, result[l].power);
    }
    printf("\n");
}

// Function to multiply two polynomials
void multiplyPolynomials(struct Term poly1[], int n1, struct Term poly2[], int n2) {
    struct Term result[n1 * n2];
    int k = 0;

    for (int i = 0; i < n1; i++) {
        for (int j = 0; j < n2; j++) {
            result[k].coeff = poly1[i].coeff * poly2[j].coeff;
            result[k].power = poly1[i].power + poly2[j].power;
            k++;
        }
    }

    // Sorting the result by power
    for (int i = 0; i < k - 1; i++) {
        for (int j = i + 1; j < k; j++) {
            if (result[i].power < result[j].power) {
                struct Term temp = result[i];
                result[i] = result[j];
                result[j] = temp;
            }
        }
    }

    // Combining like terms (same power)
    for (int i = 0; i < k - 1; i++) {
        if (result[i].power == result[i + 1].power) {
            result[i].coeff += result[i + 1].coeff;
            for (int j = i + 1; j < k - 1; j++) {
                result[j] = result[j + 1];
            }
            k--;
            i--;
        }
    }

    printf("Result of multiplication: ");
    for (int i = 0; i < k; i++) {
        if (i > 0 && result[i].coeff > 0)
            printf("+");
        printf("%dx^%d ", result[i].coeff, result[i].power);
    }
    printf("\n");
}

// Function to input a polynomial
void inputPolynomial(struct Term poly[], int *n) {
    printf("Enter number of terms: ");
    scanf("%d", n);

    for (int i = 0; i < *n; i++) {
        printf("Enter coefficient and power for term %d: ", i + 1);
        scanf("%d %d", &poly[i].coeff, &poly[i].power);
    }
}

// Function to display a polynomial
void displayPolynomial(struct Term poly[], int n) {
    for (int i = 0; i < n; i++) {
        if (i > 0 && poly[i].coeff > 0)
            printf("+");
        printf("%dx^%d ", poly[i].coeff, poly[i].power);
    }
    printf("\n");
}

int main() {
    struct Term poly1[10], poly2[10];
    int n1, n2;

    // Input polynomials
    printf("Enter first polynomial:\n");
    inputPolynomial(poly1, &n1);
    printf("Enter second polynomial:\n");
    inputPolynomial(poly2, &n2);

    // Display polynomials
    printf("First Polynomial: ");
    displayPolynomial(poly1, n1);
    printf("Second Polynomial: ");
    displayPolynomial(poly2, n2);

    // Add polynomials
    addPolynomials(poly1, n1, poly2, n2);

    // Multiply polynomials
    multiplyPolynomials(poly1, n1, poly2, n2);

    return 0;
}


->Write a program to find the sparse representation of an ordinary matrix. Also find the transpose of the matrix using the sparse representation.
#include <stdio.h>

// Structure to represent a sparse matrix element (triplet form)
struct SparseMatrix {
    int row;
    int col;
    int value;
};

// Function to convert a matrix to sparse representation
void convertToSparse(int matrix[10][10], int rows, int cols, struct SparseMatrix sparse[100], int *size) {
    *size = 0; // Initialize size of sparse matrix to 0
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (matrix[i][j] != 0) {
                sparse[*size].row = i;
                sparse[*size].col = j;
                sparse[*size].value = matrix[i][j];
                (*size)++;
            }
        }
    }
}

// Function to display the sparse matrix
void displaySparse(struct SparseMatrix sparse[100], int size) {
    printf("Row  Column  Value\n");
    for (int i = 0; i < size; i++) {
        printf("%d     %d      %d\n", sparse[i].row, sparse[i].col, sparse[i].value);
    }
}

// Function to transpose a sparse matrix
void transposeSparse(struct SparseMatrix sparse[100], int size, struct SparseMatrix transpose[100]) {
    int j = 0;
    for (int i = 0; i < size; i++) {
        transpose[i].row = sparse[i].col;
        transpose[i].col = sparse[i].row;
        transpose[i].value = sparse[i].value;
    }
}

// Main function
int main() {
    int matrix[10][10], rows, cols;
    struct SparseMatrix sparse[100], transpose[100];
    int size = 0;

    // Input matrix dimensions
    printf("Enter the number of rows and columns: ");
    scanf("%d %d", &rows, &cols);

    // Input the matrix elements
    printf("Enter the elements of the matrix:\n");
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            scanf("%d", &matrix[i][j]);
        }
    }

    // Convert the matrix to sparse representation
    convertToSparse(matrix, rows, cols, sparse, &size);

    // Display the sparse representation
    printf("\nSparse Matrix Representation:\n");
    displaySparse(sparse, size);

    // Compute the transpose of the sparse matrix
    transposeSparse(sparse, size, transpose);

    // Display the transposed sparse matrix
    printf("\nTranspose of the Sparse Matrix:\n");
    displaySparse(transpose, size);

    return 0;
}


->Write a program to add two matrices using their sparse format, and show the output like an ordinary matrix without saving it in the ordinary form.
#include <stdio.h>

// Structure to represent a sparse matrix element (triplet form)
struct SparseMatrix {
    int row;
    int col;
    int value;
};

// Function to convert a matrix to sparse representation
void convertToSparse(int matrix[10][10], int rows, int cols, struct SparseMatrix sparse[100], int *size) {
    *size = 0; // Initialize size of sparse matrix to 0
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (matrix[i][j] != 0) {
                sparse[*size].row = i;
                sparse[*size].col = j;
                sparse[*size].value = matrix[i][j];
                (*size)++;
            }
        }
    }
}

// Function to display the matrix in ordinary form (only non-zero elements)
void displayMatrix(int matrix[10][10], int rows, int cols) {
    printf("Matrix:\n");
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%d ", matrix[i][j]);
        }
        printf("\n");
    }
}

// Function to add two sparse matrices and print the result directly
void addSparseMatrices(struct SparseMatrix sparse1[100], int size1, struct SparseMatrix sparse2[100], int size2, int rows, int cols) {
    int result[10][10] = {0}; // Initialize result matrix to 0

    int i = 0, j = 0;
    
    // Traverse through both sparse matrices
    while (i < size1 || j < size2) {
        if (i < size1 && j < size2) {
            // If both elements have the same row and column
            if (sparse1[i].row == sparse2[j].row && sparse1[i].col == sparse2[j].col) {
                result[sparse1[i].row][sparse1[i].col] = sparse1[i].value + sparse2[j].value;
                i++;
                j++;
            }
            // If element of sparse1 comes before sparse2
            else if (sparse1[i].row < sparse2[j].row || (sparse1[i].row == sparse2[j].row && sparse1[i].col < sparse2[j].col)) {
                result[sparse1[i].row][sparse1[i].col] = sparse1[i].value;
                i++;
            }
            // If element of sparse2 comes before sparse1
            else {
                result[sparse2[j].row][sparse2[j].col] = sparse2[j].value;
                j++;
            }
        }
        else if (i < size1) {
            result[sparse1[i].row][sparse1[i].col] = sparse1[i].value;
            i++;
        }
        else {
            result[sparse2[j].row][sparse2[j].col] = sparse2[j].value;
            j++;
        }
    }

    // Display the result matrix (only non-zero elements)
    printf("\nResulting Matrix after Addition:\n");
    displayMatrix(result, rows, cols);
}

// Main function
int main() {
    int matrix1[10][10], matrix2[10][10], rows, cols;
    struct SparseMatrix sparse1[100], sparse2[100];
    int size1 = 0, size2 = 0;

    // Input matrix dimensions
    printf("Enter the number of rows and columns: ");
    scanf("%d %d", &rows, &cols);

    // Input the first matrix
    printf("Enter the elements of the first matrix:\n");
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            scanf("%d", &matrix1[i][j]);
        }
    }

    // Input the second matrix
    printf("Enter the elements of the second matrix:\n");
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            scanf("%d", &matrix2[i][j]);
        }
    }

    // Convert both matrices to sparse representation
    convertToSparse(matrix1, rows, cols, sparse1, &size1);
    convertToSparse(matrix2, rows, cols, sparse2, &size2);

    // Add the sparse matrices and display the result
    addSparseMatrices(sparse1, size1, sparse2, size2, rows, cols);

    return 0;
}


->Write a program to multiply 2 matrices. The function should check the possibility of multiplication
#include <stdio.h>

// Function to input a matrix
void inputMatrix(int matrix[10][10], int rows, int cols) {
    printf("Enter elements of the matrix (%d x %d):\n", rows, cols);
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            scanf("%d", &matrix[i][j]);
        }
    }
}

// Function to display a matrix
void displayMatrix(int matrix[10][10], int rows, int cols) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%d ", matrix[i][j]);
        }
        printf("\n");
    }
}

// Function to multiply two matrices
void multiplyMatrices(int A[10][10], int B[10][10], int result[10][10], int A_rows, int A_cols, int B_rows, int B_cols) {
    // Initialize the result matrix to 0
    for (int i = 0; i < A_rows; i++) {
        for (int j = 0; j < B_cols; j++) {
            result[i][j] = 0;
        }
    }

    // Multiply matrices A and B
    for (int i = 0; i < A_rows; i++) {
        for (int j = 0; j < B_cols; j++) {
            for (int k = 0; k < A_cols; k++) {
                result[i][j] += A[i][k] * B[k][j];
            }
        }
    }
}

// Function to check if matrix multiplication is possible
int canMultiply(int A_cols, int B_rows) {
    return A_cols == B_rows;
}

int main() {
    int A[10][10], B[10][10], result[10][10];
    int A_rows, A_cols, B_rows, B_cols;

    // Input dimensions for the first matrix
    printf("Enter number of rows and columns for the first matrix (A): ");
    scanf("%d %d", &A_rows, &A_cols);

    // Input dimensions for the second matrix
    printf("Enter number of rows and columns for the second matrix (B): ");
    scanf("%d %d", &B_rows, &B_cols);

    // Check if multiplication is possible
    if (!canMultiply(A_cols, B_rows)) {
        printf("Matrix multiplication is not possible. The number of columns of A must be equal to the number of rows of B.\n");
        return 1;
    }

    // Input the matrices
    inputMatrix(A, A_rows, A_cols);
    inputMatrix(B, B_rows, B_cols);

    // Multiply matrices A and B
    multiplyMatrices(A, B, result, A_rows, A_cols, B_rows, B_cols);

    // Display the result matrix
    printf("Result of matrix multiplication:\n");
    displayMatrix(result, A_rows, B_cols);

    return 0;
}


->Write a program to check whether a matrix is:
a. Identity
#include <stdio.h>

// Function to check if a matrix is an identity matrix
int isIdentityMatrix(int matrix[10][10], int n) {
    // Check the diagonal elements and off-diagonal elements
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (i == j) {
                // Diagonal elements should be 1
                if (matrix[i][j] != 1) {
                    return 0; // Not an identity matrix
                }
            } else {
                // Off-diagonal elements should be 0
                if (matrix[i][j] != 0) {
                    return 0; // Not an identity matrix
                }
            }
        }
    }
    return 1; // It is an identity matrix
}

int main() {
    int matrix[10][10], n;

    // Input the size of the matrix (square matrix)
    printf("Enter the size of the matrix (n x n): ");
    scanf("%d", &n);

    // Input the matrix elements
    printf("Enter the elements of the matrix (%d x %d):\n", n, n);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            scanf("%d", &matrix[i][j]);
        }
    }

    // Check if the matrix is an identity matrix
    if (isIdentityMatrix(matrix, n)) {
        printf("The matrix is an identity matrix.\n");
    } else {
        printf("The matrix is not an identity matrix.\n");
    }

    return 0;
}


->Write a program to check whether a matrix is:
b. diagonal
#include <stdio.h>

// Function to check if a matrix is diagonal
int isDiagonalMatrix(int matrix[10][10], int n) {
    // Check that all off-diagonal elements are zero
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (i != j) {
                if (matrix[i][j] != 0) {
                    return 0; // Not a diagonal matrix
                }
            }
        }
    }
    return 1; // It is a diagonal matrix
}

int main() {
    int matrix[10][10], n;

    // Input the size of the matrix (square matrix)
    printf("Enter the size of the matrix (n x n): ");
    scanf("%d", &n);

    // Input the matrix elements
    printf("Enter the elements of the matrix (%d x %d):\n", n, n);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            scanf("%d", &matrix[i][j]);
        }
    }

    // Check if the matrix is diagonal
    if (isDiagonalMatrix(matrix, n)) {
        printf("The matrix is a diagonal matrix.\n");
    } else {
        printf("The matrix is not a diagonal matrix.\n");
    }

    return 0;
}


->1. Write a program to implement the following operations on an integer array:
a.      Inserting data
i.       Insert at the beginning
ii.      Insert at the end
iii.     Insert at a given location (check validity of the index)
iv.     Insert after a given data (check whether the data is present)
b.      Deleting data                      
i.        delete from the beginning                
ii.       delete from the end
iii.     delete from a given location (check validity of the index)                       
iv.      delete a given data (check whether the data is present)                                          
           I.        Delete all
           II.       Delete the first one
c.      Printing content
d.      Sorting data
i.        Ascending order
ii.       Descending order
e.      Searching data
i.        Search the data and state whether it is present or not
ii.       Search the data and report the number of occurrences                      
iii.       Search the data and report the index where it is present (for multiple occurrences, report the first index)


#include <stdio.h>

#define MAX_SIZE 100

// Function to insert data at the beginning
void insertAtBeginning(int arr[], int *size, int value) {
    if (*size == MAX_SIZE) {
        printf("Array is full. Cannot insert at the beginning.\n");
        return;
    }
    for (int i = *size; i > 0; i--) {
        arr[i] = arr[i - 1];
    }
    arr[0] = value;
    (*size)++;
}

// Function to insert data at the end
void insertAtEnd(int arr[], int *size, int value) {
    if (*size == MAX_SIZE) {
        printf("Array is full. Cannot insert at the end.\n");
        return;
    }
    arr[*size] = value;
    (*size)++;
}

// Function to insert data at a given location
void insertAtLocation(int arr[], int *size, int value, int index) {
    if (*size == MAX_SIZE) {
        printf("Array is full. Cannot insert at location %d.\n", index);
        return;
    }
    if (index < 0 || index > *size) {
        printf("Invalid index. Please enter a valid index.\n");
        return;
    }
    for (int i = *size; i > index; i--) {
        arr[i] = arr[i - 1];
    }
    arr[index] = value;
    (*size)++;
}

// Function to insert data after a given value
void insertAfterValue(int arr[], int *size, int value, int data) {
    int found = 0;
    for (int i = 0; i < *size; i++) {
        if (arr[i] == data) {
            insertAtLocation(arr, size, value, i + 1);
            found = 1;
            break;
        }
    }
    if (!found) {
        printf("Data %d not found.\n", data);
    }
}

// Function to delete data from the beginning
void deleteFromBeginning(int arr[], int *size) {
    if (*size == 0) {
        printf("Array is empty. Cannot delete from beginning.\n");
        return;
    }
    for (int i = 0; i < *size - 1; i++) {
        arr[i] = arr[i + 1];
    }
    (*size)--;
}

// Function to delete data from the end
void deleteFromEnd(int arr[], int *size) {
    if (*size == 0) {
        printf("Array is empty. Cannot delete from end.\n");
        return;
    }
    (*size)--;
}

// Function to delete data from a given location
void deleteFromLocation(int arr[], int *size, int index) {
    if (*size == 0) {
        printf("Array is empty. Cannot delete from location.\n");
        return;
    }
    if (index < 0 || index >= *size) {
        printf("Invalid index. Please enter a valid index.\n");
        return;
    }
    for (int i = index; i < *size - 1; i++) {
        arr[i] = arr[i + 1];
    }
    (*size)--;
}

// Function to delete a given data (first occurrence)
void deleteData(int arr[], int *size, int value) {
    int found = 0;
    for (int i = 0; i < *size; i++) {
        if (arr[i] == value) {
            deleteFromLocation(arr, size, i);
            found = 1;
            break;
        }
    }
    if (!found) {
        printf("Data %d not found.\n", value);
    }
}

// Function to delete all occurrences of a given data
void deleteAllOccurrences(int arr[], int *size, int value) {
    int i = 0;
    while (i < *size) {
        if (arr[i] == value) {
            deleteFromLocation(arr, size, i);
        } else {
            i++;
        }
    }
}

// Function to print the contents of the array
void printArray(int arr[], int size) {
    if (size == 0) {
        printf("Array is empty.\n");
        return;
    }
    printf("Array: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

// Function to sort the array in ascending order
void sortAscending(int arr[], int size) {
    for (int i = 0; i < size - 1; i++) {
        for (int j = i + 1; j < size; j++) {
            if (arr[i] > arr[j]) {
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
    }
}

// Function to sort the array in descending order
void sortDescending(int arr[], int size) {
    for (int i = 0; i < size - 1; i++) {
        for (int j = i + 1; j < size; j++) {
            if (arr[i] < arr[j]) {
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
    }
}

// Function to search for a value and check its presence
int searchData(int arr[], int size, int value) {
    for (int i = 0; i < size; i++) {
        if (arr[i] == value) {
            return 1; // Data found
        }
    }
    return 0; // Data not found
}

// Function to count occurrences of a value
int countOccurrences(int arr[], int size, int value) {
    int count = 0;
    for (int i = 0; i < size; i++) {
        if (arr[i] == value) {
            count++;
        }
    }
    return count;
}

// Function to find the index of the first occurrence of a value
int findFirstOccurrence(int arr[], int size, int value) {
    for (int i = 0; i < size; i++) {
        if (arr[i] == value) {
            return i; // Return index of first occurrence
        }
    }
    return -1; // Value not found
}

int main() {
    int arr[MAX_SIZE], size = 0;
    int choice, value, index;

    while (1) {
        printf("\nMenu:\n");
        printf("1. Insert at beginning\n");
        printf("2. Insert at end\n");
        printf("3. Insert at given location\n");
        printf("4. Insert after a given data\n");
        printf("5. Delete from beginning\n");
        printf("6. Delete from end\n");
        printf("7. Delete from given location\n");
        printf("8. Delete a given data (first occurrence)\n");
        printf("9. Delete all occurrences of a given data\n");
        printf("10. Print array\n");
        printf("11. Sort array in ascending order\n");
        printf("12. Sort array in descending order\n");
        printf("13. Search for data (present or not)\n");
        printf("14. Count occurrences of data\n");
        printf("15. Find first occurrence of data\n");
        printf("16. Exit\n");

        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter value to insert at beginning: ");
                scanf("%d", &value);
                insertAtBeginning(arr, &size, value);
                break;
            case 2:
                printf("Enter value to insert at end: ");
                scanf("%d", &value);
                insertAtEnd(arr, &size, value);
                break;
            case 3:
                printf("Enter value to insert and location: ");
                scanf("%d %d", &value, &index);
                insertAtLocation(arr, &size, value, index);
                break;
            case 4:
                printf("Enter value to insert and data after which to insert: ");
                scanf("%d %d", &value, &index);
                insertAfterValue(arr, &size, value, index);
                break;
            case 5:
                deleteFromBeginning(arr, &size);
                break;
            case 6:
                deleteFromEnd(arr, &size);
                break;
            case 7:
                printf("Enter location to delete: ");
                scanf("%d", &index);
                deleteFromLocation(arr, &size, index);
                break;
            case 8:
                printf("Enter data to delete: ");
                scanf("%d", &value);
                deleteData(arr, &size, value);
                break;
            case 9:
                printf("Enter data to delete all occurrences: ");
                scanf("%d", &value);
                deleteAllOccurrences(arr, &size, value);
                break;
            case 10:
                printArray(arr, size);
                break;
            case 11:
                sortAscending(arr, size);
                printf("Array sorted in ascending order.\n");
                break;
            case 12:
                sortDescending(arr, size);
                printf("Array sorted in descending order.\n");
                break;
            case 13:
                printf("Enter data to search: ");
                scanf("%d", &value);
                if (searchData(arr, size, value)) {
                    printf("Data found.\n");
                } else {
                    printf("Data not found.\n");
                }
                break;
            case 14:
                printf("Enter data to count occurrences: ");
                scanf("%d", &value);
                printf("Occurrences of %d: %d\n", value, countOccurrences(arr, size, value));
                break;
            case 15:
                printf("Enter data to find first occurrence: ");
                scanf("%d", &value);
                int index = findFirstOccurrence(arr, size, value);
                if (index != -1) {
                    printf("First occurrence of %d is at index %d.\n", value, index);
                } else {
                    printf("Data not found.\n");
                }
                break;
            case 16:
                return 0;
            default:
                printf("Invalid choice. Please try again.\n");
        }
    }

    return 0;
}




->Implement the following functionalities of a singly linked list using a menu driven program:
i) Create a new list
ii) Print the list
iii)  Insert new data
      a) Insert at the first node
      b) Insert at the last node
      c) Insert into a given position
      d) Insert after a given data
iv) Delete a data from the list
      a) Delete the first node
      b) Delete at the last node
      c) Delete from a given position
      d) Delete a given data
v) Count the number of elements present in the list
vi) Search for a data
       a) Search to detect presence
       b) Search to find the position of the data
       c) Search to find how many times the data is present
vii) Sorting the list
viii) Reverse the list

ans-> 
#include <stdio.h>
#include <stdlib.h>

// Define the structure of a node
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    if (newNode == NULL) {
        printf("Memory allocation failed!\n");
        return NULL;
    }
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Function to create an empty list (initially NULL)
struct Node* createList() {
    return NULL;
}

// Function to print the list
void printList(struct Node* head) {
    if (head == NULL) {
        printf("The list is empty.\n");
        return;
    }
    struct Node* temp = head;
    printf("List: ");
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

// Function to insert a node at the beginning
struct Node* insertAtBeginning(struct Node* head, int data) {
    struct Node* newNode = createNode(data);
    newNode->next = head;
    return newNode;
}

// Function to insert a node at the end
struct Node* insertAtEnd(struct Node* head, int data) {
    struct Node* newNode = createNode(data);
    if (head == NULL) {
        return newNode;
    }
    struct Node* temp = head;
    while (temp->next != NULL) {
        temp = temp->next;
    }
    temp->next = newNode;
    return head;
}

// Function to insert a node at a given position
struct Node* insertAtPosition(struct Node* head, int data, int position) {
    if (position < 1) {
        printf("Invalid position!\n");
        return head;
    }
    struct Node* newNode = createNode(data);
    if (position == 1) {
        newNode->next = head;
        return newNode;
    }
    struct Node* temp = head;
    for (int i = 1; temp != NULL && i < position - 1; i++) {
        temp = temp->next;
    }
    if (temp == NULL) {
        printf("Position out of range!\n");
        return head;
    }
    newNode->next = temp->next;
    temp->next = newNode;
    return head;
}

// Function to insert a node after a given data
struct Node* insertAfterData(struct Node* head, int data, int afterData) {
    struct Node* temp = head;
    while (temp != NULL && temp->data != afterData) {
        temp = temp->next;
    }
    if (temp == NULL) {
        printf("Data %d not found!\n", afterData);
        return head;
    }
    struct Node* newNode = createNode(data);
    newNode->next = temp->next;
    temp->next = newNode;
    return head;
}

// Function to delete the first node
struct Node* deleteFirstNode(struct Node* head) {
    if (head == NULL) {
        printf("The list is empty.\n");
        return NULL;
    }
    struct Node* temp = head;
    head = head->next;
    free(temp);
    return head;
}

// Function to delete the last node
struct Node* deleteLastNode(struct Node* head) {
    if (head == NULL) {
        printf("The list is empty.\n");
        return NULL;
    }
    if (head->next == NULL) {
        free(head);
        return NULL;
    }
    struct Node* temp = head;
    while (temp->next != NULL && temp->next->next != NULL) {
        temp = temp->next;
    }
    free(temp->next);
    temp->next = NULL;
    return head;
}

// Function to delete a node from a given position
struct Node* deleteAtPosition(struct Node* head, int position) {
    if (head == NULL || position < 1) {
        printf("Invalid position or the list is empty!\n");
        return head;
    }
    if (position == 1) {
        struct Node* temp = head;
        head = head->next;
        free(temp);
        return head;
    }
    struct Node* temp = head;
    for (int i = 1; temp != NULL && i < position - 1; i++) {
        temp = temp->next;
    }
    if (temp == NULL || temp->next == NULL) {
        printf("Position out of range!\n");
        return head;
    }
    struct Node* nodeToDelete = temp->next;
    temp->next = temp->next->next;
    free(nodeToDelete);
    return head;
}

// Function to delete a node with a given data
struct Node* deleteData(struct Node* head, int data) {
    if (head == NULL) {
        printf("The list is empty.\n");
        return NULL;
    }
    if (head->data == data) {
        struct Node* temp = head;
        head = head->next;
        free(temp);
        return head;
    }
    struct Node* temp = head;
    while (temp->next != NULL && temp->next->data != data) {
        temp = temp->next;
    }
    if (temp->next == NULL) {
        printf("Data %d not found!\n", data);
        return head;
    }
    struct Node* nodeToDelete = temp->next;
    temp->next = temp->next->next;
    free(nodeToDelete);
    return head;
}

// Function to count the number of elements in the list
int countElements(struct Node* head) {
    int count = 0;
    struct Node* temp = head;
    while (temp != NULL) {
        count++;
        temp = temp->next;
    }
    return count;
}

// Function to search if a data exists in the list
int searchData(struct Node* head, int data) {
    struct Node* temp = head;
    while (temp != NULL) {
        if (temp->data == data) {
            return 1;
        }
        temp = temp->next;
    }
    return 0;
}

// Function to find the position of the data
int findPosition(struct Node* head, int data) {
    int position = 1;
    struct Node* temp = head;
    while (temp != NULL) {
        if (temp->data == data) {
            return position;
        }
        temp = temp->next;
        position++;
    }
    return -1;
}

// Function to count occurrences of a data
int countOccurrences(struct Node* head, int data) {
    int count = 0;
    struct Node* temp = head;
    while (temp != NULL) {
        if (temp->data == data) {
            count++;
        }
        temp = temp->next;
    }
    return count;
}

// Function to sort the list in ascending order
struct Node* sortList(struct Node* head) {
    if (head == NULL) {
        return head;
    }
    struct Node *i, *j;
    int temp;
    for (i = head; i != NULL; i = i->next) {
        for (j = i->next; j != NULL; j = j->next) {
            if (i->data > j->data) {
                temp = i->data;
                i->data = j->data;
                j->data = temp;
            }
        }
    }
    return head;
}

// Function to reverse the list
struct Node* reverseList(struct Node* head) {
    struct Node* prev = NULL;
    struct Node* current = head;
    struct Node* next = NULL;
    while (current != NULL) {
        next = current->next;
        current->next = prev;
        prev = current;
        current = next;
    }
    head = prev;
    return head;
}

// Main function to drive the menu
int main() {
    struct Node* head = NULL;
    int choice, data, position;

    while (1) {
        printf("\nMenu:\n");
        printf("1. Create a new list\n");
        printf("2. Print the list\n");
        printf("3. Insert new data\n");
        printf("4. Delete data from the list\n");
        printf("5. Count the number of elements\n");
        printf("6. Search for a data\n");
        printf("7. Sort the list\n");
        printf("8. Reverse the list\n");
        printf("9. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                head = createList();
                printf("List created.\n");
                break;
            case 2:
                printList(head);
                break;
            case 3:
                printf("Enter data to insert: ");
                scanf("%d", &data);
                printf("Choose insertion method:\n");
                printf("a) Insert at the first node\n");
                printf("b) Insert at the last node\n");
                printf("c) Insert at a given position\n");
                printf("d) Insert after a given data\n");
                printf("Enter choice: ");
                char insertChoice;
                getchar(); // to capture newline from previous input
                scanf("%c", &insertChoice);
                switch (insertChoice) {
                    case 'a':
                        head = insertAtBeginning(head, data);
                        break;
                    case 'b':
                        head = insertAtEnd(head, data);
                        break;
                    case 'c':
                        printf("Enter position: ");
                        scanf("%d", &position);
                        head = insertAtPosition(head, data, position);
                        break;
                    case 'd':
                        printf("Enter data after which to insert: ");
                        scanf("%d", &position);
                        head = insertAfterData(head, data, position);
                        break;
                    default:
                        printf("Invalid choice!\n");
                }
                break;
            case 4:
                printf("Choose deletion method:\n");
                printf("a) Delete the first node\n");
                printf("b) Delete at the last node\n");
                printf("c) Delete from a given position\n");
                printf("d) Delete a given data\n");
                printf("Enter choice: ");
                char deleteChoice;
                getchar(); // to capture newline from previous input
                scanf("%c", &deleteChoice);
                switch (deleteChoice) {
                    case 'a':
                        head = deleteFirstNode(head);
                        break;
                    case 'b':
                        head = deleteLastNode(head);
                        break;
                    case 'c':
                        printf("Enter position: ");
                        scanf("%d", &position);
                        head = deleteAtPosition(head, position);
                        break;
                    case 'd':
                        printf("Enter data to delete: ");
                        scanf("%d", &data);
                        head = deleteData(head, data);
                        break;
                    default:
                        printf("Invalid choice!\n");
                }
                break;
            case 5:
                printf("Number of elements: %d\n", countElements(head));
                break;
            case 6:
                printf("Enter data to search: ");
                scanf("%d", &data);
                printf("Search options:\n");
                printf("a) Search to detect presence\n");
                printf("b) Search to find the position\n");
                printf("c) Search to find how many times the data is present\n");
                printf("Enter choice: ");
                char searchChoice;
                getchar();
                scanf("%c", &searchChoice);
                switch (searchChoice) {
                    case 'a':
                        if (searchData(head, data)) {
                            printf("Data found.\n");
                        } else {
                            printf("Data not found.\n");
                        }
                        break;
                    case 'b':
                        position = findPosition(head, data);
                        if (position != -1) {
                            printf("Data found at position %d\n", position);
                        } else {
                            printf("Data not found.\n");
                        }
                        break;
                    case 'c':
                        printf("Data occurs %d times\n", countOccurrences(head, data));
                        break;
                    default:
                        printf("Invalid choice!\n");
                }
                break;
            case 7:
                head = sortList(head);
                printf("List sorted.\n");
                break;
            case 8:
                head = reverseList(head);
                printf("List reversed.\n");
                break;
            case 9:
                printf("Exiting...\n");
                exit(0);
            default:
                printf("Invalid choice!\n");
        }
    }
    return 0;
}



->Write a program to merge two linked lists into one.
#include <stdio.h>
#include <stdlib.h>

// Define the structure of a node
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    if (newNode == NULL) {
        printf("Memory allocation failed!\n");
        return NULL;
    }
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Function to print the list
void printList(struct Node* head) {
    if (head == NULL) {
        printf("The list is empty.\n");
        return;
    }
    struct Node* temp = head;
    printf("List: ");
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

// Function to insert a node at the end of the list
struct Node* insertAtEnd(struct Node* head, int data) {
    struct Node* newNode = createNode(data);
    if (head == NULL) {
        return newNode;
    }
    struct Node* temp = head;
    while (temp->next != NULL) {
        temp = temp->next;
    }
    temp->next = newNode;
    return head;
}

// Function to merge two linked lists
struct Node* mergeLists(struct Node* head1, struct Node* head2) {
    if (head1 == NULL) {
        return head2;  // If the first list is empty, return the second list
    }
    if (head2 == NULL) {
        return head1;  // If the second list is empty, return the first list
    }

    struct Node* temp = head1;
    // Traverse the first list to the last node
    while (temp->next != NULL) {
        temp = temp->next;
    }

    // Attach the second list to the last node of the first list
    temp->next = head2;

    return head1;
}

// Main function to drive the program
int main() {
    struct Node* list1 = NULL;
    struct Node* list2 = NULL;
    struct Node* mergedList = NULL;
    int n1, n2, data;

    // Input for the first list
    printf("Enter the number of elements for the first list: ");
    scanf("%d", &n1);

    printf("Enter the elements for the first list:\n");
    for (int i = 0; i < n1; i++) {
        printf("Element %d: ", i + 1);
        scanf("%d", &data);
        list1 = insertAtEnd(list1, data);
    }

    // Input for the second list
    printf("Enter the number of elements for the second list: ");
    scanf("%d", &n2);

    printf("Enter the elements for the second list:\n");
    for (int i = 0; i < n2; i++) {
        printf("Element %d: ", i + 1);
        scanf("%d", &data);
        list2 = insertAtEnd(list2, data);
    }

    // Printing the original lists
    printf("\nFirst List: ");
    printList(list1);
    printf("Second List: ");
    printList(list2);

    // Merging the two lists
    mergedList = mergeLists(list1, list2);

    // Printing the merged list
    printf("\nMerged List: ");
    printList(mergedList);

    return 0;
}


->Write a program to implement a linked stack with all its functionalities.
#include <stdio.h>
#include <stdlib.h>

// Define the structure of a stack node
struct Node {
    int data;
    struct Node* next;
};

// Define the structure of the stack
struct Stack {
    struct Node* top;
    int size;
};

// Function to create a new stack
struct Stack* createStack() {
    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
    if (!stack) {
        printf("Memory allocation failed!\n");
        return NULL;
    }
    stack->top = NULL;
    stack->size = 0;
    return stack;
}

// Function to check if the stack is empty
int isEmpty(struct Stack* stack) {
    return (stack->size == 0);
}

// Function to push an element onto the stack
void push(struct Stack* stack, int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    if (!newNode) {
        printf("Memory allocation failed!\n");
        return;
    }
    newNode->data = data;
    newNode->next = stack->top;
    stack->top = newNode;
    stack->size++;
    printf("Pushed %d onto the stack\n", data);
}

// Function to pop an element from the stack
int pop(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty. Cannot pop.\n");
        return -1;  // Return an invalid value when stack is empty
    }
    struct Node* temp = stack->top;
    int poppedData = temp->data;
    stack->top = stack->top->next;
    free(temp);
    stack->size--;
    printf("Popped %d from the stack\n", poppedData);
    return poppedData;
}

// Function to get the top element of the stack without removing it
int peek(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty. Cannot peek.\n");
        return -1;  // Return an invalid value when stack is empty
    }
    return stack->top->data;
}

// Function to display the stack elements
void display(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack is empty.\n");
        return;
    }
    struct Node* temp = stack->top;
    printf("Stack: ");
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

// Function to get the number of elements in the stack
int size(struct Stack* stack) {
    return stack->size;
}

// Main function
int main() {
    struct Stack* stack = createStack();
    int choice, data;

    do {
        printf("\nLinked Stack Operations:\n");
        printf("1. Push\n");
        printf("2. Pop\n");
        printf("3. Peek\n");
        printf("4. Display Stack\n");
        printf("5. Stack Size\n");
        printf("6. Check if Stack is Empty\n");
        printf("7. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter data to push: ");
                scanf("%d", &data);
                push(stack, data);
                break;
            case 2:
                pop(stack);
                break;
            case 3:
                printf("Top element: %d\n", peek(stack));
                break;
            case 4:
                display(stack);
                break;
            case 5:
                printf("Stack size: %d\n", size(stack));
                break;
            case 6:
                if (isEmpty(stack)) {
                    printf("Stack is empty.\n");
                } else {
                    printf("Stack is not empty.\n");
                }
                break;
            case 7:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 7);

    return 0;
}


->Write a program to implement a linked queue with all its functionalities.
#include <stdio.h>
#include <stdlib.h>

// Define the structure of a node
struct Node {
    int data;
    struct Node* next;
};

// Define the structure of the queue
struct Queue {
    struct Node* front;
    struct Node* rear;
    int size;
};

// Function to create a new queue
struct Queue* createQueue() {
    struct Queue* queue = (struct Queue*)malloc(sizeof(struct Queue));
    if (!queue) {
        printf("Memory allocation failed!\n");
        return NULL;
    }
    queue->front = queue->rear = NULL;
    queue->size = 0;
    return queue;
}

// Function to check if the queue is empty
int isEmpty(struct Queue* queue) {
    return (queue->size == 0);
}

// Function to enqueue (add an element) to the queue
void enqueue(struct Queue* queue, int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    if (!newNode) {
        printf("Memory allocation failed!\n");
        return;
    }
    newNode->data = data;
    newNode->next = NULL;

    if (queue->rear == NULL) {
        // If the queue is empty, both front and rear will point to the new node
        queue->front = queue->rear = newNode;
    } else {
        // Add the new node at the end of the queue and update rear
        queue->rear->next = newNode;
        queue->rear = newNode;
    }
    queue->size++;
    printf("Enqueued %d into the queue\n", data);
}

// Function to dequeue (remove an element) from the queue
int dequeue(struct Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Cannot dequeue.\n");
        return -1;  // Return an invalid value when the queue is empty
    }
    struct Node* temp = queue->front;
    int dequeuedData = temp->data;
    queue->front = queue->front->next;
    
    if (queue->front == NULL) {
        // If the queue is now empty, set rear to NULL
        queue->rear = NULL;
    }
    
    free(temp);
    queue->size--;
    printf("Dequeued %d from the queue\n", dequeuedData);
    return dequeuedData;
}

// Function to peek (view) the front element of the queue without removing it
int peek(struct Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty. Cannot peek.\n");
        return -1;  // Return an invalid value when the queue is empty
    }
    return queue->front->data;
}

// Function to display all elements in the queue
void display(struct Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty.\n");
        return;
    }
    struct Node* temp = queue->front;
    printf("Queue: ");
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

// Function to get the size of the queue
int size(struct Queue* queue) {
    return queue->size;
}

// Main function
int main() {
    struct Queue* queue = createQueue();
    int choice, data;

    do {
        printf("\nLinked Queue Operations:\n");
        printf("1. Enqueue\n");
        printf("2. Dequeue\n");
        printf("3. Peek\n");
        printf("4. Display Queue\n");
        printf("5. Queue Size\n");
        printf("6. Check if Queue is Empty\n");
        printf("7. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter data to enqueue: ");
                scanf("%d", &data);
                enqueue(queue, data);
                break;
            case 2:
                dequeue(queue);
                break;
            case 3:
                printf("Front element: %d\n", peek(queue));
                break;
            case 4:
                display(queue);
                break;
            case 5:
                printf("Queue size: %d\n", size(queue));
                break;
            case 6:
                if (isEmpty(queue)) {
                    printf("Queue is empty.\n");
                } else {
                    printf("Queue is not empty.\n");
                }
                break;
            case 7:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 7);

    return 0;
}


->Implement the following functionalities of a circular linked list using a menu driven program:
i) Create a new list
ii) Print the list
iii)  Insert new data
      a) Insert at the first node
      b) Insert at the last node
      c) Insert into a given position
      d) Insert after a given data
iv) Delete a data from the list
      a) Delete the first node
      b) Delete at the last node
      c) Delete from a given position
      d) Delete a given data
v) Count the number of elements present in the list
vi) Search for a data
       a) Search to detect presence
       b) Search to find the position of the data
       c) Search to find how many times the data is present
vii) Sorting the list
viii) Reverse the list

#include <stdio.h>
#include <stdlib.h>

// Define the structure of a node in a circular linked list
struct Node {
    int data;
    struct Node* next;
};

// Define the structure of the circular linked list
struct CircularLinkedList {
    struct Node* head;
};

// Function to create a new circular linked list
struct CircularLinkedList* createList() {
    struct CircularLinkedList* list = (struct CircularLinkedList*)malloc(sizeof(struct CircularLinkedList));
    list->head = NULL;
    return list;
}

// Function to print the list
void printList(struct CircularLinkedList* list) {
    if (list->head == NULL) {
        printf("List is empty\n");
        return;
    }

    struct Node* temp = list->head;
    do {
        printf("%d ", temp->data);
        temp = temp->next;
    } while (temp != list->head);
    printf("\n");
}

// Function to count the number of elements in the list
int countNodes(struct CircularLinkedList* list) {
    if (list->head == NULL) return 0;

    int count = 1;
    struct Node* temp = list->head;
    while (temp->next != list->head) {
        count++;
        temp = temp->next;
    }
    return count;
}

// Function to insert at the first node
void insertFirst(struct CircularLinkedList* list, int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;

    if (list->head == NULL) {
        newNode->next = newNode;  // Point to itself if list is empty
        list->head = newNode;
    } else {
        struct Node* temp = list->head;
        while (temp->next != list->head) {
            temp = temp->next;
        }
        newNode->next = list->head;
        temp->next = newNode;
        list->head = newNode;
    }
    printf("Inserted %d at the beginning\n", data);
}

// Function to insert at the last node
void insertLast(struct CircularLinkedList* list, int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;

    if (list->head == NULL) {
        newNode->next = newNode;  // Point to itself if list is empty
        list->head = newNode;
    } else {
        struct Node* temp = list->head;
        while (temp->next != list->head) {
            temp = temp->next;
        }
        temp->next = newNode;
        newNode->next = list->head;
    }
    printf("Inserted %d at the end\n", data);
}

// Function to insert at a given position
void insertAtPosition(struct CircularLinkedList* list, int data, int position) {
    int size = countNodes(list);
    if (position < 1 || position > size + 1) {
        printf("Invalid position\n");
        return;
    }

    if (position == 1) {
        insertFirst(list, data);
        return;
    }

    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    struct Node* temp = list->head;
    
    for (int i = 1; i < position - 1; i++) {
        temp = temp->next;
    }

    newNode->next = temp->next;
    temp->next = newNode;

    printf("Inserted %d at position %d\n", data, position);
}

// Function to insert after a given data
void insertAfterData(struct CircularLinkedList* list, int data, int target) {
    struct Node* temp = list->head;

    do {
        if (temp->data == target) {
            struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
            newNode->data = data;
            newNode->next = temp->next;
            temp->next = newNode;
            printf("Inserted %d after %d\n", data, target);
            return;
        }
        temp = temp->next;
    } while (temp != list->head);

    printf("Data %d not found\n", target);
}

// Function to delete the first node
void deleteFirst(struct CircularLinkedList* list) {
    if (list->head == NULL) {
        printf("List is empty\n");
        return;
    }

    struct Node* temp = list->head;
    if (temp->next == list->head) {
        free(temp);
        list->head = NULL;
    } else {
        struct Node* last = list->head;
        while (last->next != list->head) {
            last = last->next;
        }
        list->head = list->head->next;
        last->next = list->head;
        free(temp);
    }
    printf("Deleted the first node\n");
}

// Function to delete the last node
void deleteLast(struct CircularLinkedList* list) {
    if (list->head == NULL) {
        printf("List is empty\n");
        return;
    }

    struct Node* temp = list->head;
    if (temp->next == list->head) {
        free(temp);
        list->head = NULL;
    } else {
        while (temp->next->next != list->head) {
            temp = temp->next;
        }
        struct Node* last = temp->next;
        temp->next = list->head;
        free(last);
    }
    printf("Deleted the last node\n");
}

// Function to delete a given position
void deleteAtPosition(struct CircularLinkedList* list, int position) {
    int size = countNodes(list);
    if (position < 1 || position > size) {
        printf("Invalid position\n");
        return;
    }

    if (position == 1) {
        deleteFirst(list);
        return;
    }

    struct Node* temp = list->head;
    for (int i = 1; i < position - 1; i++) {
        temp = temp->next;
    }

    struct Node* toDelete = temp->next;
    temp->next = toDelete->next;
    free(toDelete);

    printf("Deleted node at position %d\n", position);
}

// Function to delete a given data
void deleteData(struct CircularLinkedList* list, int data) {
    if (list->head == NULL) {
        printf("List is empty\n");
        return;
    }

    struct Node* temp = list->head;
    struct Node* prev = NULL;
    
    do {
        if (temp->data == data) {
            if (prev == NULL) {
                deleteFirst(list);
            } else {
                prev->next = temp->next;
                free(temp);
            }
            printf("Deleted node with data %d\n", data);
            return;
        }
        prev = temp;
        temp = temp->next;
    } while (temp != list->head);

    printf("Data %d not found\n", data);
}

// Function to search for a data and return its position
int searchData(struct CircularLinkedList* list, int data) {
    if (list->head == NULL) {
        printf("List is empty\n");
        return -1;
    }

    struct Node* temp = list->head;
    int position = 1;

    do {
        if (temp->data == data) {
            return position;
        }
        temp = temp->next;
        position++;
    } while (temp != list->head);

    return -1;
}

// Function to sort the list (ascending order)
void sortList(struct CircularLinkedList* list) {
    if (list->head == NULL) {
        printf("List is empty\n");
        return;
    }

    struct Node* temp = list->head;
    int swapped;

    do {
        swapped = 0;
        temp = list->head;
        do {
            if (temp->data > temp->next->data) {
                int t = temp->data;
                temp->data = temp->next->data;
                temp->next->data = t;
                swapped = 1;
            }
            temp = temp->next;
        } while (temp->next != list->head);
    } while (swapped);

    printf("List sorted in ascending order\n");
}

// Function to reverse the list
void reverseList(struct CircularLinkedList* list) {
    if (list->head == NULL) {
        printf("List is empty\n");
        return;
    }

    struct Node* prev = NULL;
    struct Node* current = list->head;
    struct Node* next = NULL;
    struct Node* firstNode = list->head;

    do {
        next = current->next;
        current->next = prev;
        prev = current;
        current = next;
    } while (current != firstNode);

    list->head->next = prev;
    list->head = prev;

    printf("List reversed\n");
}

int main() {
    struct CircularLinkedList* list = createList();
    int choice, data, position;

    do {
        printf("\nCircular Linked List Operations:\n");
        printf("1. Create a new list\n");
        printf("2. Print the list\n");
        printf("3. Insert new data\n");
        printf("   a) Insert at the first node\n");
        printf("   b) Insert at the last node\n");
        printf("   c) Insert into a given position\n");
        printf("   d) Insert after a given data\n");
        printf("4. Delete data from the list\n");
        printf("   a) Delete the first node\n");
        printf("   b) Delete at the last node\n");
        printf("   c) Delete from a given position\n");
        printf("   d) Delete a given data\n");
        printf("5. Count the number of elements\n");
        printf("6. Search for a data\n");
        printf("7. Sort the list\n");
        printf("8. Reverse the list\n");
        printf("9. Exit\n");

        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                list = createList();
                printf("New list created\n");
                break;
            case 2:
                printList(list);
                break;
            case 3:
                printf("Enter data: ");
                scanf("%d", &data);
                printf("Enter position: ");
                scanf("%d", &position);
                insertAtPosition(list, data, position);
                break;
            case 4:
                printf("Enter data: ");
                scanf("%d", &data);
                deleteData(list, data);
                break;
            case 5:
                printf("Number of elements in the list: %d\n", countNodes(list));
                break;
            case 6:
                printf("Enter data: ");
                scanf("%d", &data);
                position = searchData(list, data);
                if (position == -1) {
                    printf("Data not found\n");
                } else {
                    printf("Data found at position %d\n", position);
                }
                break;
            case 7:
                sortList(list);
                break;
            case 8:
                reverseList(list);
                break;
            case 9:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice! Please try again.\n");
        }
    } while (choice != 9);

    return 0;
}

